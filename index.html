<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ChenWeiHui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ChenWeiHui&#39;s Blog">
<meta property="og:url" content="https://gitee.com/CWH6/index.html">
<meta property="og:site_name" content="ChenWeiHui&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cwh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/bk/atom.xml" title="ChenWeiHui&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/bk/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/bk/" id="logo">ChenWeiHui&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/bk/">Home</a>
        
          <a class="main-nav-link" href="/bk/tags">Tags</a>
        
          <a class="main-nav-link" href="/bk/archives">Archives</a>
        
          <a class="main-nav-link" href="/bk/categories">Categories</a>
        
          <a class="main-nav-link" href="/bk/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/bk/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://gitee.com/CWH6"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-【Seata】seata的部署与集成" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/10/%E3%80%90Seata%E3%80%91seata%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%9B%86%E6%88%90/" class="article-date">
  <time datetime="2023-05-10T10:34:06.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/10/%E3%80%90Seata%E3%80%91seata%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%9B%86%E6%88%90/">【Seata】seata的部署与集成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/10/%E3%80%90Seata%E3%80%91seata%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%9B%86%E6%88%90/" data-id="clhldf9g5000ggspu3dcrh5u9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-【ES6】ES6语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/10/%E3%80%90ES6%E3%80%91ES6%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2023-05-10T10:30:26.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/10/%E3%80%90ES6%E3%80%91ES6%E8%AF%AD%E6%B3%95/">【ES6】ES6语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="let定义变量"><a href="#let定义变量" class="headerlink" title="let定义变量"></a>let定义变量</h2><p><strong>1、变量不可重复声明</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let star &#x3D; &#39;苹果&#39; 
let star &#x3D; &#39;瓶子&#39;&#x2F;&#x2F;报错</code></pre>

<p><strong>2、块级作用域</strong></p>
<p>大括号内都属于作用域内</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#123; let girl &#x3D; &#39;周扬青&#39; &#125;</code></pre>

<p><strong>3、不存在变量提升</strong></p>
<p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(num) &#x2F;&#x2F; undefined
var num &#x3D; 1</code></pre>

<p><code>let</code>命令不存在变量提升的行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(num) &#x2F;&#x2F; Cannot access &#39;num&#39; before initialization
var num &#x3D; 1</code></pre>

<p><strong>4.不影响作用域链</strong></p>
<h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><p><strong>1、声明必须赋初始值</strong> </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const ONE &#x3D; 1;</code></pre>

<p><strong>2、标识符一般为大写</strong> </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const ONE &#x3D; 1;</code></pre>

<p><strong>3、常量值不能修改</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const ONE &#x3D; 1;
const ONE &#x3D; 0; &#x2F;&#x2F;报错</code></pre>

<p><strong>4、块儿级作用域</strong> </p>
<p><strong>5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const TEAM &#x3D; [&#39;UZI&#39;,&#39;MXLG&#39;,&#39;Ming&#39;,&#39;Letme&#39;];
TEAM.push(&#39;Meiko&#39;);
console.log(TEAM);&#x2F;&#x2F;[ &#39;UZI&#39;, &#39;MXLG&#39;, &#39;Ming&#39;, &#39;Letme&#39;, &#39;Meiko&#39; ]</code></pre>



<h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>
<p><strong>数组的解构赋值</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const arr &#x3D; [&#39;张学友&#39;, &#39;刘德华&#39;, &#39;黎明&#39;, &#39;郭富城&#39;];
let [zhang, liu, li, guo] &#x3D; arr;
console.log(zhang); &#x2F;&#x2F; 张学友
console.log(liu); &#x2F;&#x2F; 刘德华
console.log(li); &#x2F;&#x2F; 黎明
console.log(guo); &#x2F;&#x2F; 郭富城</code></pre>



<p><strong>对象的解构赋值</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const lin &#x3D; &#123;
  name: &#39;林志颖&#39;,
  tags: [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]
&#125;;
let &#123; name, tags &#125; &#x3D; lin;
console.log(name); &#x2F;&#x2F; &#39;林志颖&#39;
console.log(tags); &#x2F;&#x2F; [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]</code></pre>



<p><strong>复杂的解构</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let wangfei &#x3D; &#123; 
 name: &#39;王菲&#39;, 
 age: 18, 
 songs: [&#39;红豆&#39;, &#39;流年&#39;, &#39;暧昧&#39;, &#39;传奇&#39;], 
 history: [ 
 &#123;name: &#39;窦唯&#39;&#125;, 
 &#123;name: &#39;李亚鹏&#39;&#125;, 
 &#123;name: &#39;谢霆锋&#39;&#125; 
 ] 
&#125;; 
let &#123;songs: [one, two, three], history: [first, second, third]&#125; &#x3D; wangfei; </code></pre>



<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点： </p>
<p>1)字符串中可以出现换行符 </p>
<p>2)可以使用 ${xxx} 形式输出变量 </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 定义字符串 
let str &#x3D; &#96;&lt;ul&gt; 
            &lt;li&gt;魔道&lt;&#x2F;li&gt; 
            &lt;li&gt;小天才&lt;&#x2F;li&gt; 
            &lt;li&gt;星守&lt;&#x2F;li&gt; 
            &lt;li&gt;护卫&lt;&#x2F;li&gt; 
           &lt;&#x2F;ul&gt;&#96;;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 变量拼接 
let star &#x3D; &#39;王宁&#39;;
let result &#x3D; &#96;$&#123;star&#125;在前几年离开了开心麻花&#96;;
console.log(result); &#x2F;&#x2F; 王宁在前几年离开了开心麻花</code></pre>



<h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">let name &#x3D; &#39;XATU&#39;;
let slogon &#x3D; &#39;永远追求教育更高标准&#39;;
let improve &#x3D; function () &#123;
   console.log(&#39;可以提高你的技能&#39;);
&#125;

&#x2F;&#x2F;属性和方法简写 
let atguigu &#x3D; &#123;
       name,
       slogon,
      improve,
      change() &#123;
          console.log(&#39;可以改变你&#39;)
      &#125;
  &#125;;
 console.log(atguigu);</code></pre>



<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用「箭头」（**=&gt;**）定义函数。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">let fn &#x3D; (arg1, arg2, arg3) &#x3D;&gt; &#123;
     return arg1 + arg2 + arg3;
&#125;</code></pre>



<p><strong>1、如果形参只有一个，则小括号可以省略</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let fn &#x3D; str&#x3D;&gt; &#123;
    return str;
&#125;

console.log(fn(&quot;helloworld&quot;));&#x2F;&#x2F; helloworld</code></pre>



<p><strong>2、函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let fn &#x3D; str&#x3D;&gt; str;
console.log(fn(&quot;cat&quot;));&#x2F;&#x2F; cat</code></pre>



<p><strong>3、箭头函数 this 指向声明时所在作用域下 this 的值</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值
function getName() &#123;
   console.log(this.name);
&#125;

&#x2F;&#x2F; 设置 window 对象的 name 属性
window.name &#x3D; &#39;XATU&#39;;

&#x2F;&#x2F; 直接调用
getName(); &#x2F;&#x2F; XATU</code></pre>



<p><strong>4、箭头函数不能作为构造函数实例化</strong></p>
 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let Person &#x3D; (name, age) &#x3D;&gt; &#123;
     this.name &#x3D; name;
     this.age &#x3D; age;
&#125;

let me &#x3D; new Person(&#39;xiao&#39;,30);
console.log(me);

&#x2F;&#x2F; 报错 Uncaught TypeError: Person is not a constructor</code></pre>



<p><strong>5、不能使用 arguments</strong></p>
 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let fn &#x3D; () &#x3D;&gt; &#123;
     console.log(arguments);
&#125;
fn(1,2,3);

&#x2F;&#x2F; 报错 Uncaught ReferenceError: arguments is not defined</code></pre>



<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 <em>rest</em> 参数（形式为 …变量名），用于获取函数的多余参数，这样就不需要使用<em>arguments</em>对象了。<em>rest</em> 参数搭配的变量是一个<strong>数组</strong>，该变量将多余的参数放入数组中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">function add(...args) &#123;
  console.log(args);
&#125;
let str &#x3D; add(1, 2, 3, 4, 5);
console.log(str);&#x2F;&#x2F; [1, 2, 3, 4, 5]</code></pre>



<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function add(...values) &#123;
   let sum &#x3D; 0;
   for (var k of values) &#123;
      sum +&#x3D; k;
   &#125;
  return sum;
&#125;
let str &#x3D; add(2, 5, 3) 
console.log(str);&#x2F;&#x2F; 10</code></pre>



<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<p>下面是一个利用 rest 参数改写数组push方法的例子。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function push(arr, ...items) &#123;
        items.forEach(function (item) &#123;
          arr.push(item);
          console.log(item);
     &#125;);
   &#125;
var a &#x3D; [];
push(a, 1, 2, 3);</code></pre>

<p><em>rest</em> 参数必须是<strong>最后一个形参</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function minus(a, b, ...args) &#123;
    console.log(a, b, args);
&#125;
minus(100, 1, 2, 3, 4, 5, 19); &#x2F;&#x2F; 100 , 1 , [2, 3, 4, 5, 19]</code></pre>

<h2 id="spread-拓展运算符"><a href="#spread-拓展运算符" class="headerlink" title="spread 拓展运算符"></a>spread 拓展运算符</h2><p>扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let tfboys &#x3D; [&#39;德玛西亚之力&#39;, &#39;德玛西亚之翼&#39;, &#39;德玛西亚皇子&#39;];
function fn() &#123;
   console.log(arguments);
&#125;

fn(...tfboys)</code></pre>

<p><strong>数组合并</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const arr1 &#x3D; [&#39;a&#39;, &#39;b&#39;];
const arr2 &#x3D; [&#39;c&#39;];
const arr3 &#x3D; [&#39;d&#39;, &#39;e&#39;];
&#x2F;&#x2F; ES5 的合并数组
arr1.concat(arr2, arr3);
&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
&#x2F;&#x2F; ES6 的合并数组
console.log([...arr1, ...arr2, ...arr3]);
&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</code></pre>

<p><strong>与解构赋值结合：</strong></p>
<p>扩展运算符可以与<strong>解构赋值结合</strong>起来，用于生成数组。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];
console.log(first); &#x2F;&#x2F; 1
console.log(rest); &#x2F;&#x2F; [2, 3, 4, 5]</code></pre>

<p>如果将扩展运算符用于数组赋值，只能放在参数的<strong>最后一位</strong>，否则会报错。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const [...butLast, last1] &#x3D; [1, 2, 3, 4, 5];&#x2F;&#x2F; 报错
const [first, ...middle, last2] &#x3D; [1, 2, 3, 4, 5];&#x2F;&#x2F; 报错</code></pre>



<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let Uname &#x3D; [&quot;搜到&quot;, &quot;的撒&quot;, &quot;的风格&quot;, &quot;范德萨&quot;, &quot;公司发&quot;, &quot;告诉对方&quot;];
for (let a of Uname) &#123;
 console.log(a);
&#125;</code></pre>



<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>是es6引入的异步编程新的解决方案。用来封装异步操作并且可以获取其成功或者失败的结果,promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;
    setTimeout(()&#x3D;&gt;&#123;
        const data &#x3D; &#39;大奥古斯&#39;
        resolve(data)
    &#125;,4000)
&#125;).then((value)&#x3D;&gt;&#123;
    console.log(value)
&#125;,(reason)&#x3D;&gt;&#123;
    console.log(reason)
&#125;)</code></pre>



<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set:ES6提供了新的数据结构set（集合），它类似于数组，但成员的值都是唯一的，集合实现了 iterator接口，所以可以使用扩展运算符和for of进行遍历，</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;声明一个set
let se &#x3D; new Set();
let se2 &#x3D; new Set([&quot;da&quot;, &quot;xiao&quot;, &quot;gao&quot;, &quot;pang&quot;]);
console.log(se2);
&#x2F;&#x2F;添加新元素
se2.add(&quot;xishi&quot;);
console.log(se2);
&#x2F;&#x2F;删除元素
se2.delete(&quot;gao&quot;);
console.log(se2);
&#x2F;&#x2F;检测
console.log(se2.has(&quot;da&quot;));
&#x2F;&#x2F;清空
se2.clear();
console.log(se2);</code></pre>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>ES6提供了数据结构Map，它类似于对象，也是键值对的集合。但键的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map也实现了iterator接口，所以可以使用扩展运算符和for of进行遍历</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;声明一个Map
let m &#x3D; new Map();
m.set(&quot;name&quot;, &quot;zmy&quot;);
m.set(&quot;change&quot;, function () &#123;
console.log(11111);
&#125;);
let key &#x3D; &#123;
school: &quot;ahgy&quot;,
&#125;;
m.set(key, &quot;mm&quot;);
console.log(m);
&#x2F;&#x2F;size
console.log(m.size);
&#x2F;&#x2F;其中 键值 可以是字符串，也可以是对象</code></pre>

<p>输出</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Map(3) &#123;
  &#39;name&#39; &#x3D;&gt; &#39;zmy&#39;,
  &#39;change&#39; &#x3D;&gt; [Function (anonymous)],
  &#123; school: &#39;ahgy&#39; &#125; &#x3D;&gt; &#39;mm&#39;
&#125;
3</code></pre>



<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>通过class，可以定义类。基本上es6中可以看作是一个语法糖，新的class写法只是让对象原型的写法更加清晰、更加面向对象编程的语法而已。</p>
<p>类似于java的语法</p>
<p>(1) class声明类，<br>(2) constructor定义构造函数初始化，当使用new 方法名()，就会执行constructor<br>(3) extends继承父类，<br>(4) super调用父级构造方法，<br>(5) static定义静态方法和属性，<br>(6) 父类方法可以重写</p>
<p><strong>定义类构造函数，实例化类</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class phone &#123;
    &#x2F;&#x2F;构造方法，名字不能修改
    constructor(price, name) &#123;
      this.price &#x3D; price;
      this.name &#x3D; name;
    &#125;
	&#x2F;&#x2F;方法必须使用该语法，不能使用es5对象完整形式call：function&#123;&#125;
    call() &#123;
      console.log(&quot;打电话&quot;);
    &#125;
&#125;
let oneplus &#x3D; new phone(2000, &quot;华为&quot;);
console.log(oneplus);&#x2F;&#x2F; phone &#123; price: 2000, name: &#39;华为&#39; &#125;</code></pre>

<p><strong>class静态成员</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class phone&#123;
  static num &#x3D; 123
  static change()&#123;
      console.log(&#39;我可以改变世界&#39;)
  &#125;
&#125;</code></pre>

<p><strong>构造函数继承</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Phone &#123;
  &#x2F;&#x2F;构造方法
  constructor(price, name) &#123;
      this.price &#x3D; price
      this.name &#x3D; name
  &#125;
  calll() &#123;
      console.log(&#39;我可以改变世界&#39;)
  &#125;
&#125;
class smallcall extends Phone &#123;
  &#x2F;&#x2F;构造方法
  constructor(price, name, color, size) &#123;
      super(price, name) &#x2F;&#x2F;调用父类的constructor方法
      this.color &#x3D; color
      this.size &#x3D; size
  &#125;
  photo() &#123;
      console.log(&#39;111&#39;)
  &#125;
&#125;
const mi &#x3D; new smallcall(133, &#39;小米&#39;, &#39;red&#39;, 4.7)
console.log(mi);&#x2F;&#x2F; smallcall &#123; price: 133, name: &#39;小米&#39;, color: &#39;red&#39;, size: 4.7 &#125;</code></pre>

<h2 id="数值拓展"><a href="#数值拓展" class="headerlink" title="数值拓展"></a>数值拓展</h2><p><strong>1.Number.EPSILON:是JavaScript表示的最小精度</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(Number.EPSILON); &#x2F;&#x2F; 2.220446049250313e-16</code></pre>

<p> <strong>2.Number.isNaN:检测一个值是否为NaN</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(Number.isNaN(NaN)); &#x2F;&#x2F; false</code></pre>

<p> <strong>3.Number.isInteger:判断一个数是否为整数</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(Number.isInteger(1.9)); &#x2F;&#x2F; false</code></pre>

<p> <strong>4.Math.trunc:将数字的小数部分抹掉</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(Math.trunc(1.9)); &#x2F;&#x2F; 1</code></pre>

<h2 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h2><p><strong>1.Object.is:判断两个值是否相等</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let a &#x3D; &#123;&#125;;
let b &#x3D; &#123;&#125;;
console.log(Object.is(a,b)); &#x2F;&#x2F; fakse</code></pre>

<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let a &#x3D; &#123;&#125;;
let b &#x3D; a;
console.log(Object.is(a,b)); &#x2F;&#x2F; true</code></pre>



<p> <strong>2.Object.assign:对象的合并</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let a &#x3D; &#123;age:19&#125;;
let b &#x3D; &#123;name: &quot;a&quot;&#125;;
console.log(Object.assign(a,b)) &#x2F;&#x2F; &#123; age: 19, name: &#39;a&#39; &#125;</code></pre>



<p> <strong>3.Object.setPrototypeOf:设置原型对象</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;构造函数
function Person(name) &#123;
    this.name &#x3D; name;
&#125;

&#x2F;&#x2F; var p &#x3D; new Person(&quot;zhenglijing&quot;);
&#x2F;&#x2F; 等同于将构造函数的原型对象赋给实例对象p的属性__proto__
p.__proto__ &#x3D; Object.setPrototypeOf(&#123;&#125;,Person.prototype);
&#x2F;&#x2F; 通过类调用实例方法
Person.call(p,&quot;zhenglijing&quot;);</code></pre>

<h2 id="Es6模块化"><a href="#Es6模块化" class="headerlink" title="Es6模块化"></a>Es6模块化</h2><p><strong>暴露模块</strong></p>
<p>1、分别暴露：就是在每个需要暴露的变量前加export</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export  let mi &#x3D; &#39;xiaomi&#39;
export function name() &#123;
    console.log(111)
&#125;</code></pre>

<p>2、统一暴露</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let mi &#x3D; &#39;xiaomi&#39;
function name() &#123;
  console.log(111)
&#125;
export &#123;mi,name&#125;</code></pre>

<p>3、默认暴露</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;
  mi:&#39;xiaomi&#39;,
  name:function &#123;

  &#125;
&#125;</code></pre>

<p><strong>引入模块</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1.通用导入模块：import * as m from ‘&#x2F;xx.js’,其中用as定义别名为m。

2.解构赋值：import &#123;a,b as c&#125; from ‘&#x2F;xx.js’ 如果多个引入的值中有重复的会报错，可以用as如把b的值换成c，
在默认暴露default的引入中：import &#123; default as s2&#125;，不能使用default，需要用as把default重定义一个值s2

3.只有默认暴露可以使用简便的方法：import m from ‘&#x2F;xx.js’</code></pre>

<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async用于申明function异步，await用于等待一个异步方法执行完成</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><strong>1.async函数返回一个 Promise 对象</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;一个普通函数
function getData()&#123;
    return &quot;syy&quot;;
&#125;
console.log(getData())  &#x2F;&#x2F;syy
 
&#x2F;&#x2F;加上async后
async function getData()&#123;
    return &quot;syy&quot;;
&#125;
console.log(getData());  &#x2F;&#x2F;Promise &#123;&lt;resolved&gt;: &quot;syy&quot;&#125;</code></pre>

<p><strong>2、async函数内部return语句返回的值，会成为then方法回调函数的参数</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">async function getData()&#123;
    return &quot;syy&quot;;
&#125;
getData().then(data&#x3D;&gt;&#123;
    console.log(data)  &#x2F;&#x2F;syy
&#125;);</code></pre>

<p><strong>3、async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态，抛出的错误对象会被catch方法回调函数接收到</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">async function getData() &#123;
    throw new Error(&#39;出错了&#39;);
&#125;
getData()
.then(
    v &#x3D;&gt; console.log(v),
    e &#x3D;&gt; console.log(e)   &#x2F;&#x2F;Error: 出错了
)</code></pre>



<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>1.await必须放在async中。<br>2.await右侧一般都是promise对象。<br>3.await一般返回的都是promise成功过的值<br>4.await的promise失败了，会抛出异常需要try-catch进行捕获</p>
<blockquote>
<p>正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function getData()&#123;
    return new Promise((resolve,reject)&#x3D;&gt;&#123;
        setTimeout(()&#x3D;&gt;&#123;
            var name &#x3D; &quot;syy&quot;;
            resolve(name)
        &#125;,1000)
    &#125;)
&#125;
async function test()&#123;
    &#x2F;&#x2F; await
    var p &#x3D; await getData();
    console.log(p);
&#125;;
test(); &#x2F;&#x2F;syy</code></pre>







<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40322724/article/details/113919534?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168371604816800213024313%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168371604816800213024313&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113919534-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=es6%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58748792/article/details/128939637">参考2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/10/%E3%80%90ES6%E3%80%91ES6%E8%AF%AD%E6%B3%95/" data-id="clhldf9fp0005gspudmxidh3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/ES6/" rel="tag">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【k3s】K3sa安装与部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/10/%E3%80%90k3s%E3%80%91K3sa%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2023-05-10T10:02:11.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/10/%E3%80%90k3s%E3%80%91K3sa%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/">【k3s】K3s安装与部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/10/%E3%80%90k3s%E3%80%91K3sa%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/" data-id="clhldf9g8000lgspu9o4t9cjm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-【MQ】MQ概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/07/%E3%80%90MQ%E3%80%91MQ%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2023-05-07T00:50:18.000Z" itemprop="datePublished">2023-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/MQ/">MQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/07/%E3%80%90MQ%E3%80%91MQ%E6%A6%82%E8%BF%B0/">【MQ】MQ概念与选用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="MQ的概念"><a href="#MQ的概念" class="headerlink" title="MQ的概念"></a>MQ的概念</h3><p>​        MQ(message queue)，从字面意思上看，<strong>本质是个队列，FIFO 先入先出</strong>，只不过<strong>队列中存放的内容是message 而已</strong>，还是<strong>一种跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。<strong>使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</strong></p>
<h3 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h3><h4 id="1、流量消峰"><a href="#1、流量消峰" class="headerlink" title="1、流量消峰"></a>1、流量消峰</h4><p>​        举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。<strong>但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单</strong>。<strong>使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</strong></p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506101941015.png"></p>
<h4 id="2、应用解构"><a href="#2、应用解构" class="headerlink" title="2、应用解构"></a>2、应用解构</h4><p>​        以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，<strong>任何一个子系统出了故障，都会造成下单操作异常</strong>。当转变成<strong>基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506102758184.png"></p>
<h4 id="3、异步处理"><a href="#3、异步处理" class="headerlink" title="3、异步处理"></a>3、异步处理</h4><p>​        有些服务间调用是异步的，例如A 调用B，B 需要花费很长时间执行，但是A需要知道B 什么时候可以执行完，以前一般有两种方式，A过一段时间去调用 B 的查询 api 查询。或者A 提供一个callback api.B 执行完之后调用 api通知 A 服务。这两种方式都不是很优雅，<strong>使用消息总线，可以很方便解决这个问题A 调用 B 服务后，只需要监听 B 处理完成的消息，当B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api</strong>。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506103113514.png"></p>
<h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><h4 id="1、ActiveMC"><a href="#1、ActiveMC" class="headerlink" title="1、ActiveMC"></a>1、ActiveMC</h4><p>优点:单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据<br>缺点:官方社区现在对 ActiveMQ 5x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</p>
<h4 id="2、Kafka"><a href="#2、Kafka" class="headerlink" title="2、Kafka"></a>2、Kafka</h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber,Twitter,Netflix 等大公司所采纳。</p>
<p>优点:性能卓越，单机写入TPS 约在百万条/秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pul 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager; 在日志领域比较成熟，被多家公司和多个开源项目使用;功能支持功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用。</p>
<p>缺点: Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试，支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>;</p>
<h4 id="3、RocketMQ"><a href="#3、RocketMQ" class="headerlink" title="3、RocketMQ"></a>3、RocketMQ</h4><p>​        RocketMQ出自阿里巴巴的开源产品，用Java 语言实现，在设计时参考了 Kafka，并做出了自己的-些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场</p>
<p>​        优点: <strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构, <strong>消息可以做到 0 丢失</strong>,MQ功能较为完善，还是分布式的扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码定制自己公司的 MQ</p>
<p>​        缺点: <strong>支持的客户端语言不多</strong>，目前是java 及 c++，其中c++不成熟，社区活跃度一般,没有在 MQ核心中去实现JMS 等接口,有些系统要迁移需要修改大量代码</p>
<h4 id="4、-RabbitMQ"><a href="#4、-RabbitMQ" class="headerlink" title="4、 RabbitMQ"></a>4、 RabbitMQ</h4><p>​        2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前<strong>最主流的消息中间件之一</strong>。</p>
<p>​        优点:由于erlang语言的高并发特性，性能较好;<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如: Python、Ruby、.NET、JavaJMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX 文档齐全;开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高;更新频率相当高</strong></p>
<p>​        缺点:商业版需要收费,学习成本较高</p>
<h3 id="MQ的选用"><a href="#MQ的选用" class="headerlink" title="MQ的选用"></a>MQ的选用</h3><h4 id="1、Kafka"><a href="#1、Kafka" class="headerlink" title="1、Kafka"></a>1、Kafka</h4><p>​        Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于<strong>日志收集和传输</strong>，适合产生<strong>大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有日志采集功能，肯定是首选kafka了</p>
<h4 id="2、-RocketMQ"><a href="#2、-RocketMQ" class="headerlink" title="2、 RocketMQ"></a>2、 RocketMQ</h4><p>​        天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务<strong>场景在阿里双11已经经历了多次考验</strong>，如果你的业务有上述<strong>并发场景</strong>，建议可以选择 RocketMQ。</p>
<h4 id="3、-RabbitMQ"><a href="#3、-RabbitMQ" class="headerlink" title="3、 RabbitMQ"></a>3、 RabbitMQ</h4><p>​        结合erlang语言本身的<strong>并发优势性能好时效性微秒级，社区活跃度也比较高</strong>，管理界面用起来十分方便，如果你的<strong>数据量没有那么大</strong>，<strong>中小型公司</strong>优先选择功能比较完备的 RabbitMQ。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/07/%E3%80%90MQ%E3%80%91MQ%E6%A6%82%E8%BF%B0/" data-id="clhldf9g4000fgspu5bsrezve" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【RabbitMQ】消息队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2023-05-05T14:52:00.000Z" itemprop="datePublished">2023-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/MQ/">MQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">【MQ】RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h3><p>​        RabbitMQ 是一个<strong>消息中间件</strong>:它接受并转发消息。你可以把它当做一个<strong>快递站点</strong>，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是<strong>接收存储和转发消息数据</strong>。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506105149780.png"></p>
<h3 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p><strong>产生数据发送消息</strong>的程序是生产者</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它<strong>接收来自生产者的消息</strong>，另一方面它<strong>将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ和应用程序，但它们只能<strong>存储在队列中</strong>。队列仅受主机的内存和磁盘限制的约束，<strong>本质上是一个大的消息缓冲区</strong>。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费与接收具有相似的含义。消费者大多时候是一个<strong>等待接收消息的程序</strong>。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。<strong>同一个应用程序既可以是生产者又是可以是消费者。</strong></p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506105736761.png"></p>
<h3 id="RabbitMQ模式与原理"><a href="#RabbitMQ模式与原理" class="headerlink" title="RabbitMQ模式与原理"></a>RabbitMQ模式与原理</h3><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506111310491.png"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506110041118.png"></p>
<p><strong>Broker</strong>（mq实体）</p>
<p>​         接收和分发消息的应用，<em>RabbitMQ Server</em> 就是 <em>Message Broker</em></p>
<p><strong>Virtual host</strong>:</p>
<p>​         出于多租户和安全因素设计的，把 <em>AMQP</em> 的基本组件划分到一个虚拟的分组中，类似于网络中的<em>namespace</em> 概念。当多个不同的用户使用同一个RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 <em>vhost</em> 创建 <em>exchange /queue</em> 等</p>
<p><strong>Connection:</strong> </p>
<p>​        <em>publisher /consumer</em> 和 <em>broker</em> 之间的TCP连接</p>
<p><strong>chahnel:</strong>  (信道) </p>
<p>​     <strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低</strong>。Channel 是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel作为轻量级的连接Connection 极大减少了操作系统建立TCP connection 的开销  , <strong>生产者每次发送只会占用一个信道</strong>。</p>
<p><strong>Exchange</strong> ( 交换机 ) :</p>
<p>​         message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有: direct (point-to-point), topit (publish-subscribe) and fanout(multicast)</p>
<p><strong>Queue</strong>（队列）:</p>
<p>​         消息最终被送到这里等待 consumer 取走</p>
<p><strong>Binding</strong>（绑定 ）:</p>
<p>​    <strong>exchange 和queue 之间的虚拟连接，binding 中可以包含 routing key</strong>，Binding 信息被保存到exchange 中的查询表中，用于 message 的分发依据。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里直接下在 <em>Linux</em> , 可以采用Docker方式安装 ( 推荐 )</p>
<h4 id="Linux下安装MQ"><a href="#Linux下安装MQ" class="headerlink" title="Linux下安装MQ"></a>Linux下安装MQ</h4><p><strong>官网地址</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p>
<p><strong>文件上传</strong></p>
<p>上传到/usr/local/software 目录下(如果没有 software 需要自己创建, 然后下面的步骤都在改目录下执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir software
cd software</code></pre>

<p><strong>安装文件(分别按照以下顺序安装)</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># i 下载 , vh 查看下载进度 
rpm -ivh erlang-21.3-1.el7.x86_64.rpm
yum install socat -y
rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</code></pre>

<p><strong>添加开机启动RabbitMQ服务</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加开机启动 RabbitMQ服务
chkconfig rabbitmq-server on

# 启动 RabbitMQ服务
&#x2F;sbin&#x2F;service rabbitmq-server start 

# 查看 RabbitMQ服务状态
&#x2F;sbin&#x2F;service rabbitmq-server status

# 停止 RabbitMQ服务（选择执行）
&#x2F;sbin&#x2F;service rabbitmq-server stop</code></pre>

<p><strong>开启 web 管理插件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rabbitmq-plugins enable rabbitmq_management</code></pre>

<p><strong>防火墙设置（选择）</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 关闭防火墙
systemctl stop firewalld

# 查看防火墙状态
systemctl status firewalld

# 下次开机关闭防火墙
systemctl enable firewalld</code></pre>

<p><strong>访问RabbitMQ后台</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">可以使用浏览器打开web管理端：http:&#x2F;&#x2F;Server-IP:15672 </code></pre>

<p><strong>添加RabbitMQ后台用户与赋予权限</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加一个新的用户 admin  密码 123
rabbitmqctl add_user admin 123

# 设置用户角色administrator 超级管理员
rabbitmqctl set_user_tags admin administrator

# 设置用户权限 对&#x2F; 可读可写
#  set_permissions [-p &lt;vhostpath&gt; ] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;
# 用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限
rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;

# 查看当前rabbitmq的后台用户
rabbitmqctl list_users</code></pre>

<p><strong>登陆RabbitMQ后台</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">admin 123</code></pre>



<h4 id="Docker安装MQ"><a href="#Docker安装MQ" class="headerlink" title="Docker安装MQ"></a>Docker安装MQ</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 搜索mq镜像版本
docker search rabbitmq

# 拉取镜像
docker pull rabbitmq

# 查看镜像
docker imgaes</code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建并运行容器
docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 \
-v &#x2F;mq&#x2F;data:&#x2F;var&#x2F;lib&#x2F;rabbitmq  \
--hostname myRabbit  \
rabbitmq

# 删除容器
docker rm -f 080234234232</code></pre>

<p>说明</p>
<blockquote>
<p>-d 后台运行容器；<br>–name 指定容器名；<br>-p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）；<br>-v 映射目录或文件；<br>–hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看容器
docker ps -a</code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进入容器
docker exec -it 564d2be79d62 &#x2F;bin&#x2F;bash 

# 安装页面管理插件
rabbitmq-plugins enable rabbitmq_management

#创建admin用户
rabbitmqctl add_user admin admin

# 添加权限 .* 表示最高权限&#x2F;所有权限
rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;

# 添加用户名角色，这里添加为 administrator (系统管理员)
rabbitmqctl set_user_tags admin administrator</code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#重启rabbitmq
docker restart rabbitmq</code></pre>



<p><strong>访问管理后台</strong></p>
<pre class="line-numbers language-she" data-language="she"><code class="language-she">可以使用浏览器打开web管理端：http:&#x2F;&#x2F;Server-IP:15672 </code></pre>

<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230506235136342.png"></p>
<h3 id="HelloWrold"><a href="#HelloWrold" class="headerlink" title="HelloWrold"></a>HelloWrold</h3><p>用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p>
<p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p>
<p><img src="D:\imags\typora_imags\image-20230508124653059.png" alt="image-20230508124653059"></p>
<blockquote>
<p>注意</p>
<p>Java 进行连接的时候，需要 Linux 开放 5672 端口，否则会连接超时</p>
<p>访问 Web 界面的端口是 15672，连接服务器的端口是 5672</p>
</blockquote>
<p><strong>步骤</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508124901636.png" alt="image-20230508124901636"></p>
<p><strong>依赖</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;!--rabbitmq 依赖客户端--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;
        &lt;version&gt;5.8.0&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;
    &lt;!--操作文件流的一个依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;
        &lt;version&gt;2.6&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;

&lt;!--指定 jdk 编译版本--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;
            &lt;configuration&gt;
                &lt;source&gt;8&lt;&#x2F;source&gt;
                &lt;target&gt;8&lt;&#x2F;target&gt;
            &lt;&#x2F;configuration&gt;
        &lt;&#x2F;plugin&gt;
    &lt;&#x2F;plugins&gt;
&lt;&#x2F;build&gt;
</code></pre>

<h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p>
<p><strong>生产者步骤</strong></p>
<p>1、创建 RabbitMQ 连接工厂</p>
<p>2、进行 RabbitMQ 工厂配置信息</p>
<p>3、创建 RabbitMQ 连接</p>
<p>4、创建 RabbitMQ 信道</p>
<p>5、生成一个队列</p>
<p>6、发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producter &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;
    &#x2F;&#x2F;服务器端口号
    private final static String host&#x3D;&quot;192.168.124.132&quot;;
    &#x2F;&#x2F;ribbitmq登录的用户名
    private final static String name&#x3D;&quot;admin&quot;;
    &#x2F;&#x2F;ribbitmq登录的用户密码
    private final static String password&#x3D;&quot;123&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        &#x2F;&#x2F;创建一个连接工厂
        ConnectionFactory factory &#x3D; new ConnectionFactory();
        factory.setHost(host);
        factory.setUsername(name);
        factory.setPassword(password);
        &#x2F;&#x2F;创建连接
        Connection connection &#x3D; factory.newConnection();
        &#x2F;&#x2F;获取信道
        Channel channel &#x3D;connection.createChannel();
        &#x2F;**
         * 生成(声明)一个队列
         * 1.队列名称
         * 2.队列里面的消息是否持久化(磁盘) 默认true消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行共享， true 可以多个消费者消费
         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
         * 5.其他参数(Map,死信队列会用到)
         *&#x2F;
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        String message&#x3D;&quot;hello world&quot;;&#x2F;&#x2F;消息
        &#x2F;**
         * 发送一个消息
         * 1.发送到那个交换机(&quot;&quot;代表默认交换机)
         * 2.路由的 key 是哪个(队列名字)
         * 3.其他的参数信息(Map,死信队列会用到)
         * 4.发送消息的消息体(String)
         *&#x2F;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());
        System.out.println(&quot;消息发送完毕&quot;);
    &#125;
&#125;</code></pre>

<p>结果</p>
<p><img src="D:\imags\typora_imags\image-20230508125749500.png" alt="image-20230508125749500"></p>
<h4 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h4><p>创建一个类作为消费者，消费 RabbitMQ 队列的消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;
    &#x2F;&#x2F;服务器端口号
    private final static String host&#x3D;&quot;192.168.124.132&quot;;
    &#x2F;&#x2F;ribbitmq登录的用户名
    private final static String name&#x3D;&quot;admin&quot;;
    &#x2F;&#x2F;ribbitmq登录的用户密码
    private final static String password&#x3D;&quot;123&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory &#x3D; new ConnectionFactory();
        factory.setHost(host);
        factory.setUsername(name);
        factory.setPassword(password);
        
        &#x2F;&#x2F; 创建连接
        Connection connection &#x3D; factory.newConnection();
        System.out.println(&quot;等待接收消息....&quot;);
        &#x2F;&#x2F; 信道
        Channel channel &#x3D; connection.createChannel();
        
        &#x2F;&#x2F; 推送的消息如何进行消费的接口回调(消费者未成功消费的回调) 这里的写法是某种表达式，写DeliverCallback接口的实现
        &#x2F;&#x2F; 消费者成功消费的回调
        DeliverCallback deliverCallback&#x3D;(consumerTag, delivery)-&gt;&#123;
            String message&#x3D; new String(delivery.getBody());&#x2F;&#x2F;获取消息的内容体
            System.out.println(message);
        &#125;;
        
        &#x2F;&#x2F; 消费者未成功消费的回调
        CancelCallback cancelCallback&#x3D;(consumerTag)-&gt;&#123;
            System.out.println(&quot;消息消费被中断&quot;);
        &#125;;

        &#x2F;**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者成功消费的回调
         * 4.消费者未成功消费的回调
         *&#x2F;
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);

    &#125;

&#125;</code></pre>

<p><strong>结果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508130635119.png" alt="image-20230508130635119"></p>
<p><strong>日志</strong></p>
<p>生产者 (生产者程序运行多次，消费者程序就会消费多次)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">消息发送完毕</code></pre>

<p>消费者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接受消息......
hello world    </code></pre>



<h3 id="RabbitMQ工具类"><a href="#RabbitMQ工具类" class="headerlink" title="RabbitMQ工具类"></a>RabbitMQ工具类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RabbitMqUtils &#123;
    &#x2F;&#x2F;得到一个连接的 channel
    public static Channel getChannel() throws Exception&#123;
        &#x2F;&#x2F;创建一个连接工厂
        ConnectionFactory factory &#x3D; new ConnectionFactory();
        &#x2F;&#x2F;服务器端口号
        factory.setHost(&quot;192.168.124.132&quot;);
        &#x2F;&#x2F;ribbitmq登录的用户名
        factory.setUsername(&quot;admin&quot;);
        &#x2F;&#x2F;ribbitmq登录的用户密码
        factory.setPassword(&quot;123&quot;);
        &#x2F;&#x2F;创建连接
        Connection connection &#x3D; factory.newConnection();
        &#x2F;&#x2F;创建信道
        Channel channel &#x3D; connection.createChannel();
        return channel;
    &#125;
&#125;</code></pre>



<p>生产者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producter &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;创建信道
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        &#x2F;**
         * 生成(声明)一个队列
         * 1.队列名称
         * 2.队列里面的消息是否持久化(磁盘) 默认true消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
         * 5.其他参数
         *&#x2F;
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        String message&#x3D;&quot;hello world&quot;;&#x2F;&#x2F;消息
        &#x2F;**
         * 发送一个消息
         * 1.发送到那个交换机
         * 2.路由的 key 是哪个
         * 3.其他的参数信息
         * 4.发送消息的消息体
         *&#x2F;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());
        System.out.println(&quot;消息发送完毕&quot;);
    &#125;
&#125;</code></pre>



<p>消费者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;创建信道
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;等待接收消息....&quot;);
        &#x2F;&#x2F;推送的消息如何进行消费的接口回调(消费者未成功消费的回调) 这里的写法是某种表达式，写DeliverCallback接口的实现类
        DeliverCallback deliverCallback&#x3D;(consumerTag, delivery)-&gt;&#123;
            String message&#x3D; new String(delivery.getBody());&#x2F;&#x2F;获取消息的内容体
            System.out.println(message);
        &#125;;
        CancelCallback cancelCallback&#x3D;(consumerTag)-&gt;&#123;
            System.out.println(&quot;消息消费被中断&quot;);
        &#125;;

        &#x2F;**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者未成功消费的回调
         * 4.消费者未成功消费的回调
         *&#x2F;
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);

    &#125;

&#125;</code></pre>



<h3 id="工作队列与轮询"><a href="#工作队列与轮询" class="headerlink" title="工作队列与轮询"></a>工作队列与轮询</h3><h4 id="工作队列-Work-Queues"><a href="#工作队列-Work-Queues" class="headerlink" title="工作队列 Work Queues"></a>工作队列 Work Queues</h4><p>Work Queues  是工作队列（又称任务队列）的<strong>主要思想是避免立即执行资源密集型任务</strong>，而不得不等待它完成。相反<strong>我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列</strong>。在后台运行的<strong>工作进程将弹出任务并最终执行作业</strong>。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p><img src="D:\imags\typora_imags\image-20230508134309619.png" alt="image-20230508134309619"></p>
<h4 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h4><p>轮询消费消息指的是<strong>轮流</strong>消费消息，即每个工作线程都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。</p>
<p>案例中 <strong>生产者叫做 Task</strong>，<strong>一个消费者就是一个工作线程</strong>，启动两个工作线程消费消息，这个两个<strong>工作线程会以轮询的方式消费队列消息</strong>。</p>
<p><img src="D:\imags\typora_imags\image-20230508131829893.png" alt="image-20230508131829893"></p>
<h4 id="消费者轮训消费案例"><a href="#消费者轮训消费案例" class="headerlink" title="消费者轮训消费案例"></a>消费者轮训消费案例</h4><p>消费者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Wrok01 &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;

        Channel channel &#x3D; RabbitMqUtils.getChannel();
      
        DeliverCallback deliverCallback&#x3D;(consumerTag, message)-&gt;&#123;
            System.out.println(&quot;收到的消息：&quot;+new String(message.getBody()));&#x2F;&#x2F;获取消息的内容体
        &#125;;
        CancelCallback cancelCallback&#x3D;(consumerTag)-&gt;&#123;
            System.out.println(consumerTag+&quot;消息取消消费接口回调逻辑&quot;);
        &#125;;

       System.out.println(&quot;C1等待接收消息....&quot;); 
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);
    &#125;

&#125;</code></pre>

<p><strong>IDEA一个消费者类启动两个线程</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508132918882.png" alt="image-20230508132918882"></p>
<p><img src="D:\imags\typora_imags\image-20230508132936311.png" alt="image-20230508132936311"></p>
<p>启动一个消费者先</p>
<p><img src="D:\imags\typora_imags\image-20230508133006027.png" alt="image-20230508133006027"></p>
<p>修改该类的打印信息后，再运行</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;c2等待接收消息....&quot;)</code></pre>



<p><img src="D:\imags\typora_imags\image-20230508133120621.png" alt="image-20230508133120621"></p>
<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class Task02 &#123;
    &#x2F;&#x2F;消息队列名称
    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        &#x2F;**
         * 生成(声明)一个队列
         * 1.队列名称
         * 2.队列里面的消息是否持久化(磁盘) 默认true消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
         * 5.其他参数
         *&#x2F;
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        &#x2F;&#x2F;String message&#x3D;&quot;hello world&quot;;&#x2F;&#x2F;消息
        &#x2F;&#x2F;从控制台中接受信息
        Scanner scanner &#x3D; new Scanner(System.in);
        while (scanner.hasNext()) &#123;
            String message &#x3D; scanner.next();
            &#x2F;**
             * 发送一个消息
             * 1.发送到那个交换机
             * 2.路由的 key 是哪个
             * 3.其他的参数信息
             * 4.发送消息的消息体
             *&#x2F;
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            System.out.println(&quot;消息发送完毕：&quot; + message);
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>结果</strong></p>
<p>消费者发送消息: AA , BB </p>
<p><img src="D:\imags\typora_imags\image-20230508133541746.png" alt="image-20230508133541746"></p>
<p>消费者c1 接受队列中 ”AA消息“ 并处理</p>
<p><img src="D:\imags\typora_imags\image-20230508133610189.png" alt="image-20230508133610189"></p>
<p>消费者c2 接受队列中 ”BB消息“ 并处理</p>
<p><img src="D:\imags\typora_imags\image-20230508133614081.png" alt="image-20230508133614081"></p>
<blockquote>
<p>结论：一个用户可能有多个消费者线程来接受消息，但是这些</p>
<p>线程不能收到一样的消息，rabbitmq底层中采用轮询接受（类似于nginx的负载均衡），否则用户会收到相同的信息</p>
</blockquote>
<h3 id="RabbitMQ应答与发布"><a href="#RabbitMQ应答与发布" class="headerlink" title="RabbitMQ应答与发布"></a>RabbitMQ应答与发布</h3><p>即：消息应答与发布</p>
<pre><code>    消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。**RabbitMQ  一旦向消费者传递了一条消息，便立即将该消息标记为删除**。在这种情况下，突然有个**消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为它无法接收到**。
</code></pre>
<h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><pre><code>    **消息发送后立即被认为已经传送成功**，这种模式需要在**高吞吐量和数据传输安全性方面做权衡**,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，**没有对传递的消息数量进行限制**，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，**所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。**
</code></pre>
<h4 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h4><p>消费者线程在消费完消息后，进行应答，RabbitMQ收到后将对应的消息从信道中删除，手动应答好处是：可以批量应答并且减少网路拥堵</p>
<h5 id="手动应答方法"><a href="#手动应答方法" class="headerlink" title="手动应答方法"></a>手动应答方法</h5><p><code>Channel.basicAck</code> (肯定确认应答)：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 第一个参数：消息的标记，
 * 第二个参数：是否批处理，
 * 消费者通知RabbitMQ，消息被成功处理，RabbitMQ将其从队列中删除
 *&#x2F;
basicAck(long deliveryTag, boolean multiple);</code></pre>

<p><code>Channel.basicReject</code> (否定确认应答)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 
 * 第一个参数：拒绝消息的标记，
 * 第二个参数：是否重新入队。 true 则重新入队列，false 则丢弃或者进入死信队列。
 * 该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。
 *&#x2F;
basicReject(long deliveryTag, boolean requeue);</code></pre>

<p><code>Channel.basicNack</code> (用于否定确认)：表示己拒绝处理该消息，可以将其从队列删除</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 第一个参数: 拒绝消息的标记，
 * 第二个参数：是否批处理，
 * 第三个参数：是否重新入队，
 * 与 basicReject 区别：
 * 同时支持多个消息，
 * 可以拒绝签收 该消费者先前接收未 ack 的所有消息，拒绝签收后的消息也会被自己消费到。
 *&#x2F;
basicNack(long deliveryTag, boolean multiple, boolean requeue);</code></pre>

<p>Channel.basicRecover</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 是否恢复消息到队列，
 * 参数是否从新入队，true 则重新入队列，
 * 并且尽可能的将之前 recover 的消息投递给其他消费者消费，而不是自己再次消费。
 * false 则消息会重新被投递给自己。
 *&#x2F;
basicRecover(boolean requeue);</code></pre>



<h5 id="手动应答的批处理"><a href="#手动应答的批处理" class="headerlink" title="手动应答的批处理"></a>手动应答的批处理</h5><p>multiple 的 true 和 false 代表不同意思，true 代表批量应答。 channel 上未应答的消息</p>
<p>如： channel 上有传送 tag 的消息为 5,6,7,8 ，当前 tag 是8。</p>
<p>multiple为true:   那么此时5-8 的这些还未应答的消息都会被确认（RabbitMQ认为这些tag (5~8) 的消息都被应答 所以在队列中删除）。</p>
<p>multiple为 false : 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答（RabbitMQ认为这些tag=8的消息都被应答 所以在</p>
<p>队列中删除）</p>
<p>如图：</p>
<p><strong>批处理</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508142414724.png" alt="image-20230508142414724"></p>
<p><strong>不批处理</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508142423818.png" alt="image-20230508142423818"></p>
<p><img src="D:\imags\typora_imags\image-20230508143513802.png" alt="image-20230508143513802"></p>
<h5 id="消息自动从新入队"><a href="#消息自动从新入队" class="headerlink" title="消息自动从新入队"></a>消息自动从新入队</h5><p>如果<strong>消费者由于某些原因失去连接</strong>(其通道已关闭，连接已关闭或 TCP 连接丢失)，<strong>导致消息未发送 ACK 确认，RabbitMQ  将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者</strong>。这样，即使某个消费者偶尔死亡，也可以<strong>确保不会丢失</strong>任何消息。</p>
<h4 id="手动应答案例"><a href="#手动应答案例" class="headerlink" title="手动应答案例"></a>手动应答案例</h4><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>
<p>消费者启用两个线程，消费 1 一秒消费一个消息，消费者 2 十秒消费一个消息，然后在消费者 2 消费消息的时候，停止运行，这时正在消费的消息是否会重新进入队列，而后给消费者 1 消费呢？</p>
<p><strong>休眠工具类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SleepUtils &#123;
    public static void sleep(int second)&#123;
        try &#123;
            Thread.sleep(1000*second);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>消费者1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;消费者
public class Work031 &#123;
    private static final String ACK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;C1 等待接收消息处理时间较短&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody());
            SleepUtils.sleep(1);
            System.out.println(&quot;接收到消息:&quot; + message);
            &#x2F;**
             * 下面形参
             * 1.消息标记 tag
             * 2.是否批量应答未应答消息
             *&#x2F;
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        &#125;;
        &#x2F;&#x2F;采用手动应答
        boolean autoAck &#x3D; false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;
            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);
        &#125;);
    &#125;
&#125;</code></pre>

<p><strong>消费者2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;消费者
public class Work032 &#123;
    private static final String ACK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;C2 等待接收消息处理时间较长&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody());
            SleepUtils.sleep(30);
            System.out.println(&quot;接收到消息:&quot; + message);
            &#x2F;**
             * 下面形参
             * 1.消息标记 tag
             * 2.是否批量应答未应答消息
             *&#x2F;
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        &#125;;
        &#x2F;&#x2F;采用手动应答
        boolean autoAck &#x3D; false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;
            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);
        &#125;);
    &#125;
&#125;</code></pre>

<p><strong>消息生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Task03 &#123;
    private static final String TASK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        channel.queueDeclare(TASK_QUEUE_NAME,false,false,false,null);
        System.out.println(&quot;请输入信息：&quot;);
        Scanner scanner &#x3D; new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String msg &#x3D; scanner.next();
            channel.basicPublish(&quot;&quot;,TASK_QUEUE_NAME,null,msg.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发送消息：&quot;+msg);
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>测试</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">假如work032消费者宕机（模拟-关闭程序）了，手动应答则会将消息放回队列中，交由work031去消费消息</code></pre>

<p><strong>生产者</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508152634625.png" alt="image-20230508152634625"></p>
<p><strong>消费者2</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508152645564.png" alt="image-20230508152645564"></p>
<p><strong>消费者1</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508152745435.png" alt="image-20230508152745435"></p>
<h4 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h4><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的<strong>消息都将会被指派一个唯一的 ID(从1 开始)<strong>，一旦消息被投递到所有匹配的队列之后，</strong>broker就会发送一个确认给生产者(包含消息的唯一 ID)<strong>，这就</strong>使得生产者知道消息已经正确到达目的队列了</strong>，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<pre><code>    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。
</code></pre>
<p><img src="D:\imags\typora_imags\image-20230509101704604.png" alt="image-20230509101704604"></p>
<h5 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h5><p>发布确认默认是没有开启的，如果要开启需要调用方法 <em>confirmSelect</em>，每当你要想使用发布确认，都需要在 <em>channel</em> 上调用该方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Channel channel &#x3D; connection.createChannel();
channel.confirmSelect();</code></pre>



<h5 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h5><pre><code>    这是一种简单的确认方式，它是一种**同步确认发布**的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。
    这种确认方式有一个最大的**缺点**就是:**发布速度特别的慢**，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供**每秒不超过数百条发布消息的吞吐量**。当然对于某些应用程序来说这可能已经足够了。
</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConfirmMessage &#123;
    &#x2F;&#x2F;发布的消息数量
    private static final Integer MESSAGE_COUNT &#x3D; 1000;

    public static void main(String[] args) throws Exception&#123;
        &#x2F;&#x2F;单条确认
        publishMessageIndividually();
        &#x2F;&#x2F;批量确认
        &#x2F;&#x2F;多条确认
    &#125;

    private static void publishMessageIndividually() throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        String queueName &#x3D; UUID.randomUUID().toString();
        channel.queueDeclare(queueName, true, false, false, null);
        &#x2F;&#x2F;开启发布确认
        channel.confirmSelect();
        long begin &#x3D; System.currentTimeMillis();
        for (Integer i &#x3D; 0; i &lt; MESSAGE_COUNT; i++) &#123;
            String message &#x3D; i + &quot;&quot;;&#x2F;&#x2F;消息
            channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());
 			 &#x2F;&#x2F;队列发送确认
            boolean flag &#x3D; channel.waitForConfirms();
            if (flag) &#123;
                System.out.println(&quot;消息发送成功&quot;);
            &#125;
        &#125;
        long end &#x3D; System.currentTimeMillis();
        System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个单独确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);

    &#125;
&#125;</code></pre>

<blockquote>
<p>确认发布指的是成功发送到了队列，并不是消费者消费了消息。</p>
</blockquote>
<p><strong>效果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509103220597.png" alt="image-20230509103220597"></p>
<p>​        </p>
<h5 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h5><pre><code>    单个确认发布那种方式非常慢，与单个等待确认消息相比，**先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了**，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。
</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConfirmMessage &#123;
    &#x2F;&#x2F;发布的消息数量
    private static final Integer MESSAGE_COUNT &#x3D; 1000;

   public static void main(String[] args) throws Exception &#123;
        &#x2F;&#x2F;单条确认
        &#x2F;&#x2F;publishMessageIndividually();
        &#x2F;&#x2F;批量确认
        publishMessageBatch();
        &#x2F;&#x2F;异步确认
    &#125;

	private static void publishMessageBatch() throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        String queueName &#x3D; UUID.randomUUID().toString();
        channel.queueDeclare(queueName, true, false, false, null);
        &#x2F;&#x2F;开启发布确认
        channel.confirmSelect();
        &#x2F;&#x2F;确认消息的条数
        int batchSize &#x3D; 100;
        long begin &#x3D; System.currentTimeMillis();
        for (Integer i &#x3D; 0; i &lt; MESSAGE_COUNT; i++) &#123;
            String message &#x3D; i + &quot;&quot;;&#x2F;&#x2F;消息
            channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());
            &#x2F;&#x2F;队列发送确认 (100条消息就确认一次)
            if (i % batchSize &#x3D;&#x3D; 0) &#123;
                &#x2F;&#x2F;确认
                channel.waitForConfirms();
            &#125;
        &#125;
        long end &#x3D; System.currentTimeMillis();
        System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;批量单独确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);

	&#125;
&#125;</code></pre>



<p><img src="D:\imags\typora_imags\image-20230509103536225.png" alt="image-20230509103536225"></p>
<h5 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h5><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功。</p>
<p><strong>原理图</strong></p>
<p>采用一个map 去映射消息序号与消息内容</p>
<p><img src="D:\imags\typora_imags\image-20230509104050281.png" alt="image-20230509104050281"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static void publishMessageAsync() throws Exception &#123;
    Channel channel &#x3D; RabbitMqUtils.getChannel();
    String queueName &#x3D; UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    &#x2F;&#x2F;开启发布确认
    channel.confirmSelect();
    long begin &#x3D; System.currentTimeMillis();
    &#x2F;**
     * 确认收到消息的一个回调
     * 1.消息序列号  map的key
     * 2.true 可以确认小于等于当前序列号的消息
     * false 确认当前序列号消息
     *&#x2F;
    &#x2F;&#x2F;收到消息的成功回调函数（消息未有丢失）
    ConfirmCallback ackCallback&#x3D;(deliveryTag, multiple)-&gt;&#123;
        System.out.println(&quot;确认的发布消息，序列号&quot;+deliveryTag);
    &#125;;
    &#x2F;&#x2F;未收到消息的回调函数（消息丢失）
    ConfirmCallback nackCallback&#x3D;(deliveryTag, multiple)-&gt;&#123;
        System.out.println(&quot;未确认的发布消息，序列号&quot;+deliveryTag);
    &#125;;
    &#x2F;**
     * 添加一个异步确认的监听器（监听哪些消息成功，哪些消息失败）
     * 1.确认收到消息的回调
     * 2.未收到消息的回调
     *&#x2F;
    channel.addConfirmListener(ackCallback,nackCallback);&#x2F;&#x2F;参数设置为null为不监听
    for (Integer i &#x3D; 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message &#x3D; i + &quot;&quot;;&#x2F;&#x2F;消息
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());
    &#125;
    long end &#x3D; System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;异步确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);

&#125;</code></pre>

<p><strong>结果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509104806837.png" alt="image-20230509104806837"></p>
<h5 id="处理异步未确认消息"><a href="#处理异步未确认消息" class="headerlink" title="处理异步未确认消息"></a>处理异步未确认消息</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static void publishMessageAsync() throws Exception &#123;
    Channel channel &#x3D; RabbitMqUtils.getChannel();
    String queueName &#x3D; UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    &#x2F;&#x2F;开启发布确认
    channel.confirmSelect();
    &#x2F;**
     * 线程安全有序的一个哈希表，适用于高并发的情况
     * 1.轻松的将序号与消息进行关联
     * 2.轻松批量删除条目 只要给到序列号
     * 3.支持并发访问
     *&#x2F;
    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms &#x3D; new
            ConcurrentSkipListMap&lt;&gt;();

    long begin &#x3D; System.currentTimeMillis();
    &#x2F;**
     * 确认收到消息的一个回调
     * 1.消息序列号  map的key
     * 2.true 可以确认小于等于当前序列号的消息
     * false 确认当前序列号消息
     *&#x2F;
    &#x2F;&#x2F;收到消息的成功回调函数（消息未有丢失）
    ConfirmCallback ackCallback&#x3D;(deliveryTag, multiple)-&gt;&#123;
        System.out.println(&quot;确认的发布消息，序列号&quot;+deliveryTag);
        if (multiple) &#123;&#x2F;&#x2F;批量处理
            &#x2F;&#x2F;返回的是小于等于当前序列号的一组【未确认消息】 是一个 map
            ConcurrentNavigableMap&lt;Long, String&gt; confirmed &#x3D;
                    outstandingConfirms.headMap(deliveryTag, true);
            &#x2F;&#x2F;清除该部分未确认消息
            confirmed.clear();
        &#125;else&#123;&#x2F;&#x2F;单个
            &#x2F;&#x2F;只清除当前序列号的消息&#x3D;全部消息map-确认消息map
            outstandingConfirms.remove(deliveryTag);
        &#125;

    &#125;;
    &#x2F;&#x2F;未收到消息的回调函数（消息丢失）
    ConfirmCallback nackCallback&#x3D;(deliveryTag, multiple)-&gt;&#123;
 &#x2F;&#x2F;打印未有确认的消息
        String message &#x3D; outstandingConfirms.get(deliveryTag);
        System.out.println(&quot;未确认的发布消息&quot;+deliveryTag+&quot;，序列号&quot;+deliveryTag);
    &#125;;
    &#x2F;**
     * 添加一个异步确认的监听器（监听哪些消息成功，哪些消息失败）
     * 1.确认收到消息的回调
     * 2.未收到消息的回调
     *&#x2F;
    channel.addConfirmListener(ackCallback,nackCallback);&#x2F;&#x2F;参数设置为null为不监听
    for (Integer i &#x3D; 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message &#x3D; i + &quot;&quot;;&#x2F;&#x2F;消息
        &#x2F;**
         * channel.getNextPublishSeqNo()获取下一个消息的序列号
         * 通过序列号与消息体进行一个关联
         * 全部都是未确认的消息体
         *&#x2F;
        outstandingConfirms.put(channel.getNextPublishSeqNo(),message);
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());
    &#125;
    long end &#x3D; System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;异步确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);

&#125;</code></pre>



<h5 id="三种确认发布对比"><a href="#三种确认发布对比" class="headerlink" title="三种确认发布对比"></a>三种确认发布对比</h5><ul>
<li><p>单独发布消息</p>
<p>同步等待确认，简单，但吞吐量非常有限。</p>
</li>
<li><p>批量发布消息</p>
<p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p>
</li>
<li><p>异步处理</p>
<p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>
</li>
</ul>
<h4 id="应答和发布的区别"><a href="#应答和发布的区别" class="headerlink" title="应答和发布的区别"></a>应答和发布的区别</h4><p>应答功能属于消费者，消费完消息告诉 RabbitMQ 已经消费成功。</p>
<p>发布功能属于生产者，生产消息到 RabbitMQ，RabbitMQ 需要告诉生产者已经收到消息。</p>
<h3 id="RbbitMQ-持久化"><a href="#RbbitMQ-持久化" class="headerlink" title="RbbitMQ 持久化"></a>RbbitMQ 持久化</h3><p>上面的手动应答可以处理消费者丢失消息的情况，但是<strong>如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失</strong>。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。<strong>确保消息不会丢失需要做两件事: 我们需要将队列和消息都标记为持久化</strong>。</p>
<h4 id="队列实现持久化"><a href="#队列实现持久化" class="headerlink" title="队列实现持久化"></a>队列实现持久化</h4><p>之前我们创建的队列都是非持久化的，rabbitmg 如果重启的化，该队列就会被删除掉，如果要队列<strong>实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Task02 &#123;

    &#x2F;&#x2F;队列名称
    public static final String TASK_QUEUE_NAME &#x3D; &quot;ACK_QUEUE&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;开启持久化
        boolean durable &#x3D; true;
        &#x2F;&#x2F;声明队列
        channel.queueDeclare(TASK_QUEUE_NAME,durable,false,false,null);
        &#x2F;&#x2F;在控制台中输入信息
        Scanner scanner &#x3D; new Scanner(System.in);
        System.out.println(&quot;请输入信息：&quot;);
        while (scanner.hasNext())&#123;
            String message &#x3D; scanner.next();
            channel.basicPublish(&quot;&quot;,TASK_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息:&quot;+ message);
        &#125;

    &#125;
&#125;</code></pre>





<blockquote>
<p>注意</p>
<p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p>
</blockquote>
<p>不然就会出现如下错误：</p>
<p><img src="D:\imags\typora_imags\image-20230508154754896.png" alt="image-20230508154754896"></p>
<p><img src="D:\imags\typora_imags\image-20230508154822574.png" alt="image-20230508154822574"></p>
<h4 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h4><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p>
<p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Task02 &#123;

    &#x2F;&#x2F;队列名称
    public static final String TASK_QUEUE_NAME &#x3D; &quot;ACK_QUEUE&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;队列持久化
        boolean durable &#x3D; true;
        &#x2F;&#x2F;声明队列
        channel.queueDeclare(TASK_QUEUE_NAME,durable,false,false,null);
        &#x2F;&#x2F;在控制台中输入信息
        Scanner scanner &#x3D; new Scanner(System.in);
        System.out.println(&quot;请输入信息：&quot;);
        while (scanner.hasNext())&#123;
            String message &#x3D; scanner.next();
        	&#x2F;&#x2F;设置生产者发送消息为持久化消息(要求保存到磁盘上)
            channel.basicPublish(&quot;&quot;,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息:&quot;+ message);
        &#125;

    &#125;
&#125;
</code></pre>





<h3 id="RabbitMQ不公分发与预取值"><a href="#RabbitMQ不公分发与预取值" class="headerlink" title="RabbitMQ不公分发与预取值"></a>RabbitMQ不公分发与预取值</h3><h4 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h4><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的<strong>轮训分发</strong>，但是在某种场景下这种策略并不是很好，<strong>比方说有两个消费者在处理任务，其中有个消费者 1处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好</strong>，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
<p>为了避免这种情况，我们可以设置参数 channel.basicQos(1);</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int prefetchCount &#x3D; 1;
channel.basicQos(prefetchCount);</code></pre>



<pre><code>    意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。
</code></pre>
<p><strong>消费者</strong></p>
<p>生产者发送多个消息，消费者中效率高的处理多条消息，效率低的处理少量消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;消费者
public class Work032 &#123;
    private static final String ACK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;C2 等待接收消息处理时间较长&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody());
            SleepUtils.sleep(30);
            System.out.println(&quot;接收到消息:&quot; + message);
            &#x2F;**
             * 下面形参
             * 1.消息标记 tag
             * 2.是否批量应答未应答消息
             *&#x2F;
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        &#125;;
        
        &#x2F;&#x2F;不公平分发为1（效率高，能者多劳），公平分发为0
        int prefetchCount &#x3D; 1;
        channel.basicQos(prefetchCount);
        
        &#x2F;&#x2F;采用手动应答
        boolean autoAck &#x3D; false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;
            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);
        &#125;);
    &#125;
&#125;</code></pre>

<p><strong>效果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230508170139289.png" alt="image-20230508170139289"></p>
<h4 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h4><pre><code>    本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此**希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题**。这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。**该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认**，例如，假设在通道上有末确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ak，比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。**通常，增加预取将提高向消费者传递消息的速度**。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理
</code></pre>
<p>的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，<strong>消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大</strong>，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p>效率高的工作线程（消费者）的信道的预期值 设置高点，避免消息在其他信道积压,下面的图就无语（反例子）</p>
<p><img src="D:\imags\typora_imags\image-20230508171023479.png" alt="image-20230508171023479"></p>
<blockquote>
<p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为 1，代表不公平分发，取值不为1，代表预取值分发</p>
</blockquote>
<p><strong>消费者1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;消费者
public class Work031 &#123;
    private static final String ACK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;C1 等待接收消息处理时间较长&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody());
            SleepUtils.sleep(1);
            System.out.println(&quot;接收到消息:&quot; + message);
            &#x2F;**
             * 下面形参
             * 1.消息标记 tag
             * 2.是否批量应答未应答消息
             *&#x2F;
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        &#125;;
        
        &#x2F;&#x2F; 值不等于 1，则代表预取值,预取值为6
        int prefetchCount &#x3D; 6;
        channel.basicQos(prefetchCount);
        
        &#x2F;&#x2F;采用手动应答
        boolean autoAck &#x3D; false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;
            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);
        &#125;);
    &#125;
&#125;</code></pre>



<p><strong>消费者2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;消费者
public class Work032 &#123;
    private static final String ACK_QUEUE_NAME &#x3D; &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        System.out.println(&quot;C2 等待接收消息处理时间较长&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody());
            SleepUtils.sleep(30);
            System.out.println(&quot;接收到消息:&quot; + message);
            &#x2F;**
             * 下面形参
             * 1.消息标记 tag
             * 2.是否批量应答未应答消息
             *&#x2F;
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        &#125;;
        
        &#x2F;&#x2F; 值不等于 1，则代表预取值,预取值为2
        int prefetchCount &#x3D; 2;
        channel.basicQos(prefetchCount);
        
        &#x2F;&#x2F;采用手动应答
        boolean autoAck &#x3D; false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;
            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);
        &#125;);
    &#125;
&#125;</code></pre>



<p><strong>效果</strong></p>
<p>生产者</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">生产者生产多条消息: AA BB CC </code></pre>

<p>消费者们</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">消费者1（效率高）的信道（缓存区）先分配了AA， 消费者2（效率低）的信道（缓存区）分配了BB， 根据预测值将CC 放到消费者1的信道，两者分别去消费。</code></pre>



<h3 id="RabbitMQ交换机"><a href="#RabbitMQ交换机" class="headerlink" title="RabbitMQ交换机"></a>RabbitMQ交换机</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>    RabbitMQ 消息传递模型的核心思想是: **生产者生产的消息从不会直接发送到队列**。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。
    相反，**生产者只能将消息发送到交换机(exchange)**，**交换机**工作的内容非常简单，一方面它**接收来自生产者的消息**，另一方面**将它们推入队列**。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。
</code></pre>
<h4 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h4><p>前面部分我们对exchange无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 第一个参数空字符为默认交换机
channel.basicPublish(&quot;&quot;,&quot;hello&quot;，null,message.getBytes());</code></pre>

<h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><pre><code>    之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗? )队列的名称我们来说至关重要-我们需要**指定我们的消费者去消费哪个队列的消息**。
    每当我们连接到 RabbitMQ 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次**一旦我们断开了消费者的连接，队列将被自动删除**。
</code></pre>
<p>创建临时队列的方式如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String queueName &#x3D; channel.queueDecare().getQueue();</code></pre>



<p><img src="D:\imags\typora_imags\image-20230509113025142.png" alt="image-20230509113025142"></p>
<h4 id="后台交换机绑定队列"><a href="#后台交换机绑定队列" class="headerlink" title="后台交换机绑定队列"></a>后台交换机绑定队列</h4><p>交换机通过routingkey绑定队列，通过key的值来将消费发到指定的队列中去</p>
<p><strong>创建队列</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509113237758.png" alt="image-20230509113237758"></p>
<p><strong>创建交换机</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509113358297.png" alt="image-20230509113358297"></p>
<p><strong>绑定交换机</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509113542776.png" alt="image-20230509113542776"></p>
<p><strong>效果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509113613609.png" alt="image-20230509113613609"></p>
<h4 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h4><ul>
<li><p><strong>直接(direct)</strong></p>
<pre><code>  处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的**路由键完全匹配**。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键  abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。
</code></pre>
</li>
<li><p><strong>主题(topic)</strong></p>
<pre><code>  **将路由键和某模式进行匹配**。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def
</code></pre>
</li>
<li><p><strong>标题(headers)</strong></p>
<pre><code>  不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange  时指定一组键值对；**当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange  绑定时指定的键值对进行匹配**；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是  Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。
</code></pre>
</li>
</ul>
<p>匹配规则 x-match 有下列两种类型：</p>
<p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p>
<p>x-match = any ：表示只要有键值对匹配就能接受到消息</p>
<ul>
<li><p><strong>扇出(fanout)</strong> ：</p>
<pre><code>    不处理路由键。你只需要简单的将队列绑定到交换机上。**一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上**。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。
</code></pre>
</li>
</ul>
<h4 id="Fanout-交换机"><a href="#Fanout-交换机" class="headerlink" title="Fanout 交换机"></a>Fanout 交换机</h4><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘</p>
<p><img src="D:\imags\typora_imags\image-20230509120220406.png" alt="image-20230509120220406"></p>
<p><strong>Logs（交换机） 和临时队列的绑定关系</strong></p>
<p>消费者们创建共同交换机（logs），共同交换机设置路由key (fanout ), 分别创建无名队列 (交换机一个routing key: fanout)</p>
<blockquote>
<p>注意</p>
<p>先启动两个消费者再启动生产者。</p>
<p>生产者生产消息后，如果没有对应的消费者接收，则该消息是遗弃的消息</p>
</blockquote>
<p><strong>消费者1</strong></p>
<p>将接收到的消息打印在控制台</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogs02 &#123;
    private static final String EXCHANGE_NAME &#x3D; &quot;logs&quot;;

    public static void main(String[] args) throws Exception&#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        &#x2F;&#x2F;定义各发布订阅的交换机
        channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;);
        &#x2F;&#x2F;临时消息队列，名字随机，断开连接后自动删除
        String queueName &#x3D; channel.queueDeclare().getQueue();
        &#x2F;&#x2F;绑定  队列名字，交换机名字，绑定的key
        channel.queueBind(queueName,EXCHANGE_NAME,&quot;&quot;);
        System.out.println(&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody(), &quot;UTF-8&quot;);
            System.out.println(&quot;控制台打印接收到的消息&quot;+message);
        &#125;;

        channel.basicConsume(queueName,deliverCallback,consumerTag -&gt; &#123; &#125;);
    &#125;
&#125;</code></pre>



<p><strong>消费者2</strong></p>
<p>把消息写出到文件（代码中暂时为打印到控制台）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogs01 &#123;
    &#x2F;&#x2F;交换机名字
    private static final String EXCHANGE_NAME &#x3D; &quot;logs&quot;;

    public static void main(String[] args) throws Exception&#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        &#x2F;&#x2F;定义各发布订阅的交换机
        channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;);
        &#x2F;&#x2F;临时消息队列，名字随机，断开连接后自动删除
        String queueName &#x3D; channel.queueDeclare().getQueue();
        &#x2F;&#x2F;绑定  队列名字，交换机名字，绑定的key
        channel.queueBind(queueName,EXCHANGE_NAME,&quot;&quot;);
        System.out.println(&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt; &#123;
            String message &#x3D; new String(delivery.getBody(), &quot;UTF-8&quot;);
            System.out.println(&quot;控制台打印接收到的消息&quot;+message);
        &#125;;

        channel.basicConsume(queueName,deliverCallback,consumerTag -&gt; &#123; &#125;);
    &#125;

&#125;
</code></pre>

<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class EmitLog &#123;
    &#x2F;&#x2F;交换机名字
    private static final String EXCHANGE_NAME &#x3D; &quot;logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel &#x3D; RabbitMqUtils.getChannel();
        &#x2F;&#x2F;声明交换机这里无需声明了，因为消费者中创建了，该交换机已经存在
        &#x2F;&#x2F;channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);
        Scanner scanner &#x3D; new Scanner(System.in);
        while (scanner.hasNext()) &#123;
            String message &#x3D; scanner.nextLine();
            &#x2F;&#x2F;发给 哪个交换机 routingkey 其他 messaeg的字节码
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
            System.out.println(&quot;生产者发出消息&quot; + message);
        &#125;

    &#125;
&#125;</code></pre>

<p><strong>效果</strong></p>
<p><strong>生产者发送消息</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">aa
生产者发出消息aa    </code></pre>

<p><strong>消费者1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收消息，把接收到的消息打印在屏幕.....
控制台打印接收到的消息aa</code></pre>

<p><strong>消费者2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收消息，把接收到的消息打印在屏幕.....
控制台打印接收到的消息aa</code></pre>



<h4 id="direct-交换机"><a href="#direct-交换机" class="headerlink" title="direct 交换机"></a>direct 交换机</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><pre><code>    **我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间**。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的routingKey 队列中去。
</code></pre>
<p><strong>一个队列可以绑定多个路由key</strong></p>
<pre><code>    在上面这张图中,我们可以看到X绑定了两个队列,绑定类型是 diret,队列 Q1 绑定键为 orange队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.
    在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。
</code></pre>
<p><img src="D:\imags\typora_imags\image-20230509151053852.png" alt="image-20230509151053852"></p>
<h5 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h5><p><strong>多个队列可以绑定同一路由</strong></p>
<pre><code>    当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就**和 fanout 有点类似了，就跟广播差不多**，如下图所示
</code></pre>
<p><img src="D:\imags\typora_imags\image-20230509151859682.png" alt="image-20230509151859682"></p>
<h5 id="Direct实战"><a href="#Direct实战" class="headerlink" title="Direct实战"></a>Direct实战</h5><p>关系</p>
<p><img src="D:\imags\typora_imags\image-20230509152129151.png" alt="image-20230509152129151"></p>
<p>交换机</p>
<p><img src="D:\imags\typora_imags\image-20230509152151798.png" alt="image-20230509152151798"></p>
<p>C1 消费者：绑定 console 队列，routingKey 为 info、warning</p>
<p>C2 消费者：绑定 disk 队列，routingKey 为 error</p>
<p>当生产者生产消息到 <code>direct_logs</code> 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。</p>
<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @author frx
 * @version 1.0
 * @date 2022&#x2F;7&#x2F;24  21:59
 *&#x2F;
public class DirectLogs &#123;

    &#x2F;&#x2F;交换机名称
    public static final String EXCHANGE_NAME &#x3D; &quot;direct_logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();


        Scanner scanner &#x3D; new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message &#x3D; scanner.next();
            channel.basicPublish(EXCHANGE_NAME,&quot;info&quot;,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息:&quot;+message);
        &#125;
    &#125;
&#125;
</code></pre>

<p><strong>消费者1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogsDirect01 &#123;

    public static final String EXCHANGE_NAME&#x3D;&quot;direct_logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
        &#x2F;&#x2F;声明一个direct交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        &#x2F;&#x2F;声明一个队列
        channel.queueDeclare(&quot;console&quot;,false,false,false,null);
        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME,&quot;info&quot;);
        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME,&quot;warning&quot;);
        &#x2F;&#x2F;接收消息
        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt; &#123;
          System.out.println(&quot;ReceiveLogsDirect01控制台打印接收到的消息:&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;
        &#x2F;&#x2F;消费者取消消息时回调接口
        channel.basicConsume(&quot;console&quot;,true,deliverCallback,consumerTag -&gt; &#123;&#125;);

    &#125;
&#125;</code></pre>



<p><strong>消费者2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogsDirect02 &#123;

    public static final String EXCHANGE_NAME&#x3D;&quot;direct_logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
        &#x2F;&#x2F;声明一个direct交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        &#x2F;&#x2F;声明一个队列
        channel.queueDeclare(&quot;disk&quot;,false,false,false,null);
        channel.queueBind(&quot;disk&quot;,EXCHANGE_NAME,&quot;error&quot;);

        &#x2F;&#x2F;接收消息
        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt; &#123;
          System.out.println(&quot;ReceiveLogsDirect02控制台打印接收到的消息:&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;
        &#x2F;&#x2F;消费者取消消息时回调接口
        channel.basicConsume(&quot;disk&quot;,true,deliverCallback,consumerTag -&gt; &#123;&#125;);

    &#125;
&#125;</code></pre>

<p><strong>结果</strong></p>
<p><strong>生产者控制台</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">11
生产者发出消息:11</code></pre>

<p><strong>消费者1控制台</strong></p>
<pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">ReceiveLogsDirecto1控制台打印接收到的消息:11</code></pre>

<p><strong>消费者2控制台</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#96;&#96;&#96;



#### Topics 交换机

##### 介绍

在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。

尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 **topic** 类型



##### **Topic 的要求**

发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是**一个单词列表**，**以点号分隔开**。这些单词可以是任意单词

比如说：&quot;stock.usd.nyse&quot;, &quot;nyse.vmw&quot;, &quot;quick.orange.rabbit&quot; 这种类型的。

当然这个单词列表最多不能超过 255 个字节。

在这个规则列表中，其中有两个替换符是大家需要注意的：



- ***(星号)可以代替一个位置**
- **#(井号)可以替代零个或多个位置**



##### Topic匹配案例

下图绑定关系如下：

![image-20230509155740461](D:\imags\typora_imags\image-20230509155740461.png)

- Q1--&gt;绑定的是

  - 中间带 orange 带 3 个单词的字符串 &#96;(*.orange.*)&#96;

- Q2--&gt;绑定的是

  - 最后一个单词是 rabbit 的 3 个单词 &#96;(*.*.rabbit)&#96;

  - 第一个单词是 lazy 的多个单词 &#96;(lazy.#)&#96;

    

上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的

| 例子                     | 说明                                       |
| ------------------------ | ------------------------------------------ |
| quick.orange.rabbit      | 被队列 Q1Q2 接收到                         |
| lazy.orange.elephant     | 被队列 Q1Q2 接收到                         |
| quick.orange.fox         | 被队列 Q1 接收到                           |
| lazy.brown.fox           | 被队列 Q2 接收到                           |
| lazy.pink.rabbit         | 虽然满足Q2两个绑定但只被队列 Q2 接收一次   |
| quick.brown.fox          | 不匹配任何绑定不会被任何队列接收到会被丢弃 |
| quick.orange.male.rabbit | 是四个单词不匹配任何绑定会被丢弃           |
| lazy.orange.male.rabbit  | 是四个单词但匹配 Q2                        |

注意

&gt; 当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了
&gt;
&gt; 如果队列绑定键当中没有 # 和 * 出现，那么该队列绑定类型就是 direct 了

#### 

**交换机**

&lt;img src&#x3D;&quot;D:\imags\typora_imags\image-20230509160546725.png&quot; alt&#x3D;&quot;image-20230509160546725&quot; style&#x3D;&quot;zoom:67%;&quot; &#x2F;&gt;



生产多个消息到交换机，交换机按照通配符分配消息到不同的队列中，队列由消费者进行消费



**生产者**

&#96;&#96;&#96;java
public class EmitLogTopic &#123;

    &#x2F;&#x2F;交换机的名称
    public static final String EXCHANGE_NAME &#x3D; &quot;topic_logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
        &#x2F;**
         * Q1--&gt;绑定的是
         *      中间带 orange 带 3 个单词的字符串(*.orange.*)
         * Q2--&gt;绑定的是
         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)
         *      第一个单词是 lazy 的多个单词(lazy.#)
         *&#x2F;
        HashMap&lt;String, String&gt; bindingKeyMap &#x3D; new HashMap&lt;&gt;();
        bindingKeyMap.put(&quot;quick.orange.rabbit&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.orange.elephant&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;quick.orange.fox&quot;, &quot;被队列 Q1 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.brown.fox&quot;, &quot;被队列 Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.pink.rabbit&quot;, &quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;);
        bindingKeyMap.put(&quot;quick.brown.fox&quot;, &quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;);
        bindingKeyMap.put(&quot;quick.orange.male.rabbit&quot;, &quot;是四个单词不匹配任何绑定会被丢弃&quot;);
        bindingKeyMap.put(&quot;lazy.orange.male.rabbit&quot;, &quot;是四个单词但匹配 Q2&quot;);
        for (Map.Entry&lt;String,String&gt; bindingKeyEntry : bindingKeyMap.entrySet())&#123;
            String routingKey &#x3D; bindingKeyEntry.getKey();
            String message &#x3D; bindingKeyEntry.getValue();

            channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息:&quot;+message);
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>消费者C1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogsTopic01 &#123;

    &#x2F;&#x2F;交换机的名称
    public static final String EXCHANGE_NAME &#x3D; &quot;topic_logs&quot;;

    &#x2F;&#x2F;接收消息
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
        &#x2F;&#x2F;声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        &#x2F;&#x2F;声明队列
        String queueName &#x3D; &quot;Q1&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        channel.queueBind(queueName,EXCHANGE_NAME,&quot;*.orange.*&quot;);
        System.out.println(&quot;等待接收消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt; &#123;
            System.out.println(new String(message.getBody(),&quot;UTF-8&quot;));
            System.out.println(&quot;接收队列：&quot;+queueName+&quot;  绑定键:&quot;+message.getEnvelope().getRoutingKey());
        &#125;;
        &#x2F;&#x2F;接收消息
        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt;&#123;&#125;);
    &#125;
&#125;</code></pre>

<p><strong>消费者C2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReceiveLogsTopic02 &#123;

    &#x2F;&#x2F;交换机的名称
    public static final String EXCHANGE_NAME &#x3D; &quot;topic_logs&quot;;

    &#x2F;&#x2F;接收消息
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
        &#x2F;&#x2F;声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        &#x2F;&#x2F;声明队列
        String queueName &#x3D; &quot;Q2&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        channel.queueBind(queueName,EXCHANGE_NAME,&quot;*.*.rabbit&quot;);
        channel.queueBind(queueName,EXCHANGE_NAME,&quot;lazy.#&quot;);

        System.out.println(&quot;等待接收消息...&quot;);
        
        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt; &#123;
            System.out.println(new String(message.getBody(),&quot;UTF-8&quot;));
            System.out.println(&quot;接收队列：&quot;+queueName+&quot;  绑定键:&quot;+message.getEnvelope().getRoutingKey());
        &#125;;
        &#x2F;&#x2F;接收消息
        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt;&#123;&#125;);
    &#125;
&#125;</code></pre>

<p><strong>结果</strong></p>
<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">生产者发出消息: 是四个单词不匹配任何绑定会被丢弃
生产者发出消息:不匹配任何绑定不会被任何队列接收到会被丢弃
生产者发出消息:被队列 Q1Q2 接收到生产者发出消息:被队列 Q2 接收到
生产者发出消息:被队列 Q102 接收到
生产者发出消息:被队列 Q1 接收到
生产者发出消息: 虽然满足两个绑定但只被队列 02 接收一次
生产者发出消息:是四个单词但匹配 Q2</code></pre>



<p><strong>消费者C1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收消息...
    
被队列 Q102 接收到
接收队列: Q1 绑定键:lazy.orange.elephant
    
被队列 Q102 接收到
接收队列: Q1 绑定键:quick.orange.rabbit
    
被队列 Q1 接收到
接收队列: 01 绑定键:quick.orange.fox</code></pre>



<p><strong>消费者C2</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收消息...
被队列 Q102 接收到
接收队列: Q2 绑定键: lazy.orange.elephant
    
被队列 Q2 接收到
接收队列: Q2 绑定键:lazy.brown.fox
    
被队列 Q102 接收到
接收队列:Q2 绑定键:quick.orange.rabbit
    
虽然满足两个绑定但只被队列 Q2 接收一次
接收队列:Q2 绑定键:Lazy.pink.rabbit
    
是四个单词但匹配 Q2
接受队列：Q2 绑定键值：lazy.orange.male.rabbit </code></pre>



<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><pre><code>    先从概念解释上搞清楚这个定义，死信，顾名思义就是**无法被消费的消息**，字面意思可以这样理一般来说，producer 将消息投递到broker 或者直接到queue 里了,consumer 从 aueue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有续的处理，就变成了死信，有死信自然就有了死信队列。
</code></pre>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>1）保证订单业务的消息数据不丢失，需要使用到RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中</p>
<p>2）用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p>
<h4 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h4><ul>
<li>消息TTL过期</li>
</ul>
<p>TTL是 Time To Live 的缩写, 也就是生存时间</p>
<ul>
<li>队列达到最大长度</li>
</ul>
<p>队列满了，无法再添加数据到 MQ 中</p>
<ul>
<li>消息被拒绝</li>
</ul>
<p>（basic.reject 或 basic.nack) 并且 requeue = false</p>
<h4 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h4><h5 id="消息TTL过期"><a href="#消息TTL过期" class="headerlink" title="消息TTL过期"></a>消息TTL过期</h5><p>交换机的类型是 direct，两个消费者，一个生产者，两个队列：消息队列和死信队列</p>
<p><img src="D:\imags\typora_imags\image-20230509181153362.png" alt="image-20230509181153362"></p>
<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producer &#123;
    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;
    
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
     	 &#x2F;&#x2F;设置普通交换机 消费者已经定义这里就不需要定义了
        &#x2F;&#x2F;channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        &#x2F;&#x2F;死信消息 设置ttl时间 live to time 单位是ms
        AMQP.BasicProperties properties &#x3D;
                new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        for (int i &#x3D; 1; i &lt;11 ; i++) &#123;
            String message &#x3D; &quot;info&quot;+i;
            channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,properties,message.getBytes());
        &#125;
    &#125;
&#125;
</code></pre>



<p><strong>消费者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer01 &#123;

    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;
    &#x2F;&#x2F;死信交换机的名称
    public static final String DEAD_EXCHANGE &#x3D; &quot;dead_exchange&quot;;

    &#x2F;&#x2F;普通队列的名称
    public static final String NORMAL_QUEUE &#x3D; &quot;normal_queue&quot;;
    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_QUEUE &#x3D; &quot;dead_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;

        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;声明死信和普通交换机，类型为direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);

        &#x2F;&#x2F;声明普通队列
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;过期时间 10s 由生产者指定 更加灵活(上面已经指定了，这里就不用了)
        &#x2F;&#x2F;arguments.put(&quot;x-message-ttl&quot;,10000);
        &#x2F;&#x2F;正常的队列设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);&#x2F;&#x2F;图中红箭头
        &#x2F;&#x2F;设置死信routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;);

        channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;声明死信队列
        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);

        &#x2F;&#x2F;绑定普通的交换机与队列
        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;);

        &#x2F;&#x2F;绑定死信的交换机与死信的队列
        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;);
        System.out.println(&quot;等待接收消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt;&#123;
            System.out.println(&quot;Consumer01接受的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;

        channel.basicConsume(NORMAL_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125;);
    &#125;


&#125;</code></pre>

<p>先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息</p>
<p><strong>生产者未发送消息</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509190931805.png" alt="image-20230509190931805"></p>
<p><strong>生产者发送了10条消息，此时正常消息队列有10条未消费消息</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509191008799.png" alt="image-20230509191008799"></p>
<p><strong>时间过去10秒，正常队列里面的消息由于没有被消费，消息进入死信队列</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509191045989.png" alt="image-20230509191045989"></p>
<p><strong>消费者C2</strong></p>
<p>消费死信队列的消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer02 &#123;

    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_QUEUE &#x3D; &quot;dead_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;

        Channel channel &#x3D; RabbitMQUtils.getChannel();

        System.out.println(&quot;等待接收死信消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, message) -&gt;&#123;
            System.out.println(&quot;Consumer02接受的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;

        channel.basicConsume(DEAD_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125;);
    &#125;
&#125;</code></pre>

<p><strong>效果</strong></p>
<p><img src="D:\imags\typora_imags\image-20230509191512715.png" alt="image-20230509191512715"></p>
<p>消费者2的控制台</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收死信消息...
Consumer02接受的消息是: info1
Consumer02接受的消息是: info2
Consumer02接受的消息是: info3
Consumer02接受的消息是: info4
Consumer02接受的消息是: info5
Consumer02接受的消息是: info6
Consumer02接受的消息是: info7
Consumer02接受的消息是: info8
Consumer02接受的消息是: info9
Consumer02接受的消息是: info10</code></pre>





<h5 id="死信最大长度"><a href="#死信最大长度" class="headerlink" title="死信最大长度"></a>死信最大长度</h5><p><strong>消费者</strong></p>
<p>1 消息生产者代码去掉 TTL 属性，<code>basicPublish</code> 的第三个参数改为 null</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producer &#123;
    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;死信消息 设置ttl时间 live to time 单位是ms
        &#x2F;&#x2F;AMQP.BasicProperties properties &#x3D;
        &#x2F;&#x2F;        new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        for (int i &#x3D; 1; i &lt;11 ; i++) &#123;
            String message &#x3D; &quot;info&quot;+i;
            channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,null,message.getBytes());
        &#125;
    &#125;
&#125;
</code></pre>



<h5 id="私信消息被拒"><a href="#私信消息被拒" class="headerlink" title="私信消息被拒"></a>私信消息被拒</h5><p>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</p>
<p>这里 设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer01 &#123;

    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;
    &#x2F;&#x2F;死信交换机的名称
    public static final String DEAD_EXCHANGE &#x3D; &quot;dead_exchange&quot;;

    &#x2F;&#x2F;普通队列的名称
    public static final String NORMAL_QUEUE &#x3D; &quot;normal_queue&quot;;
    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_QUEUE &#x3D; &quot;dead_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;

        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;声明死信和普通交换机，类型为direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);

        &#x2F;&#x2F;声明普通队列
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;过期时间 10s 由生产者指定 更加灵活
        &#x2F;&#x2F;arguments.put(&quot;x-message-ttl&quot;,10000);
        &#x2F;&#x2F;正常的队列设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);&#x2F;&#x2F;图中红箭头
        &#x2F;&#x2F;设置死信routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;);
        &#x2F;&#x2F;设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信
        arguments.put(&quot;x-max-length&quot;,6);
        
        channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;声明死信队列
        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);

        &#x2F;&#x2F;绑定普通的交换机与队列
        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;);

        &#x2F;&#x2F;绑定死信的交换机与死信的队列
        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;);
        System.out.println(&quot;等待接收消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt;&#123;
            System.out.println(&quot;Consumer01接受的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;

        channel.basicConsume(NORMAL_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125;);
    &#125;

&#125;</code></pre>

<blockquote>
<p>注意</p>
<p>因为参数改变了，所以需要把原先队列删除</p>
</blockquote>
<p><strong>消费者c2</strong></p>
<p>消费死信队列的消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer02 &#123;

    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_QUEUE &#x3D; &quot;dead_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;

        Channel channel &#x3D; RabbitMQUtils.getChannel();

        System.out.println(&quot;等待接收死信消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag, message) -&gt;&#123;
            System.out.println(&quot;Consumer02接受的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));
        &#125;;

        channel.basicConsume(DEAD_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125;);
    &#125;
&#125;</code></pre>



<p>启动消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</p>
<p><img src="D:\imags\typora_imags\image-20230509212507208.png" alt="image-20230509212507208"></p>
<p>启动 C2 消费者,消费死信消息</p>
<p><img src="D:\imags\typora_imags\image-20230509212530299.png" alt="image-20230509212530299"></p>
<p><strong>消费者c2的控制台</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收死信消息..
Consumer02接受的消息是: info1
Consumer02接受的消息是: info2
Consumer02接受的消息是:info3
Consumer02接受的消息是:info4</code></pre>



<h5 id="死信消息被拒"><a href="#死信消息被拒" class="headerlink" title="死信消息被拒"></a>死信消息被拒</h5><p>1、消息生产者代码同上生产者一致</p>
<p>2、需求：消费者 C1 拒收消息 “info5”，开启手动应答</p>
<p><strong>生产者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producer &#123;
    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;
    
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
     	 &#x2F;&#x2F;设置普通交换机 消费者已经定义这里就不需要定义了
        &#x2F;&#x2F;channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        &#x2F;&#x2F;死信消息 设置ttl时间 live to time 单位是ms
        &#x2F;&#x2F;AMQP.BasicProperties properties &#x3D;
        &#x2F;&#x2F;        new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        for (int i &#x3D; 1; i &lt;11 ; i++) &#123;
            String message &#x3D; &quot;info&quot;+i;
            channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,null,message.getBytes());
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>消费者C1</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Consumer01 &#123;

    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;
    &#x2F;&#x2F;死信交换机的名称
    public static final String DEAD_EXCHANGE &#x3D; &quot;dead_exchange&quot;;

    &#x2F;&#x2F;普通队列的名称
    public static final String NORMAL_QUEUE &#x3D; &quot;normal_queue&quot;;
    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_QUEUE &#x3D; &quot;dead_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;

        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;声明死信和普通交换机，类型为direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);

        &#x2F;&#x2F;声明普通队列
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;过期时间 10s 由生产者指定 更加灵活
        &#x2F;&#x2F;arguments.put(&quot;x-message-ttl&quot;,10000);
        &#x2F;&#x2F;正常的队列设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);&#x2F;&#x2F;图中红箭头
        &#x2F;&#x2F;设置死信routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;);
        &#x2F;&#x2F;设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信
        &#x2F;&#x2F;arguments.put(&quot;x-max-length&quot;,6);

        channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;声明死信队列
        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);

        &#x2F;&#x2F;绑定普通的交换机与队列
        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;);

        &#x2F;&#x2F;绑定死信的交换机与死信的队列
        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;);
        System.out.println(&quot;等待接收消息...&quot;);

        DeliverCallback deliverCallback &#x3D; (consumerTag,message) -&gt;&#123;
            String msg &#x3D; new String(message.getBody(), &quot;UTF-8&quot;);
            if(msg.equals(&quot;info5&quot;))&#123;
                System.out.println(&quot;Consumer01接受的消息是：&quot;+msg+&quot;： 此消息是被C1拒绝的&quot;);
                &#x2F;&#x2F;requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中
                channel.basicReject(message.getEnvelope().getDeliveryTag(), false);
            &#125;else &#123;
                System.out.println(&quot;Consumer01接受的消息是：&quot;+msg);
                channel.basicAck(message.getEnvelope().getDeliveryTag(), false);
            &#125;

        &#125;;
        &#x2F;&#x2F;开启手动应答，也就是关闭自动应答
        channel.basicConsume(NORMAL_QUEUE,false,deliverCallback,consumerTag -&gt; &#123;&#125;);
    &#125;

&#125;</code></pre>

<p>开启消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</p>
<p><img src="D:\imags\typora_imags\image-20230509215213815.png" alt="image-20230509215213815"></p>
<p>启动消费者 C1 等待 10 秒之后，死信队列中存在消息</p>
<p><img src="D:\imags\typora_imags\image-20230509215239219.png" alt="image-20230509215239219"></p>
<p>再启动消费者 C2消费死信队列</p>
<p><strong>消费者c1控制台</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收消息..
Consumer01接受的消息是: info1
Consumer01接受的消息是: info2
Consumer01接受的消息是: info3
Consumer01接受的消息是: info4
Consumer01接受的消息是: info5:此消息是被C1拒绝的
Consumer01接受的消息是: info6
Consumer01接受的消息是: info7
Consumer01接受的消息是:info8
Consumer01接受的消息是: info9
Consumer01接受的消息是: info10</code></pre>



<p><strong>消费者c2控制台</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">等待接收死信消息..
Consumer02接受的消息是:info5</code></pre>

<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><h4 id="延迟队列概念："><a href="#延迟队列概念：" class="headerlink" title="延迟队列概念："></a>延迟队列概念：</h4><p>延时队列,<strong>队列内部是有序的</strong>，最重要的特性就体现在它的<strong>延时属性</strong>上，延时队列中的元素是希望 <strong>在指定时间到了以后或之前取出和处理</strong>，简单来说，<strong>延时队列就是用来存放需要在指定时间被处理的 元素的队列</strong>。</p>
<h4 id="延迟队列使用场景："><a href="#延迟队列使用场景：" class="headerlink" title="延迟队列使用场景："></a>延迟队列使用场景：</h4><ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ol>
<pre><code>    这些场景都有一个特点，**需要在某个事件发生之后或者之前的指定时间点完成某一项任务**，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？



    如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求，  如果对于**时间不是严格限制**，而是宽松意义上的一周，那么每天晚上**跑个定时任务检查**一下所有未支付的账单，确实也是一个可行的方案。但**对于数据量比较大，并且时效性较强的场景**，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用**轮询的方式显然是不可取的**，很可能在一秒内无法完成所有订单的检查，同时会**给数据库带来很大压力**，无法满足业务要求而且性能低下。
</code></pre>
<p><img src="D:\imags\typora_imags\image-20230509222008163.png" alt="image-20230509222008163"></p>
<h4 id="TTL的两种设置"><a href="#TTL的两种设置" class="headerlink" title="TTL的两种设置"></a>TTL的两种设置</h4><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p>
<p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条<strong>消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」</strong>。如果<strong>同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL</strong>。</p>
<p><strong>队列设置TTL</strong></p>
<p>在创建队列的时候设置队列的 x-message-ttl 属性</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String, Object&gt; params &#x3D; new HashMap&lt;&gt;();
params.put(&quot;x-message-ttl&quot;,5000);
return QueueBuilder.durable(&quot;QA&quot;).withArguments(args).build(); &#x2F;&#x2F; QA 队列的最大存活时间位 5000 毫秒
</code></pre>

<p><strong>消息设置TTL</strong></p>
<p>针对每条消息设置 TTL</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">rabbitTemplate.converAndSend(&quot;X&quot;,&quot;XC&quot;,message,correlationData -&gt; &#123;
    correlationData.getMessageProperties().setExpiration(&quot;5000&quot;);
&#125;);</code></pre>



<p><strong>两者区别</strong></p>
<p>如果设置了队列的 TTL  属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p>
<p>另外，还需要注意的一点是，<strong>如果不设置 TTL，表示消息永远不会过期</strong>，如果将<strong>TTL 设置为 0</strong>，则表示<strong>除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</strong></p>
<h4 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h4><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ  实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL  则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p>
<p>1、创建一个 Maven 工程或者 Spring Boot工程</p>
<p>2、添加依赖，这里的 Spring Boot 是2.5.5 版本</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.5.5&lt;&#x2F;version&gt;
    &lt;relativePath&#x2F;&gt; 
&lt;&#x2F;parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;
        &lt;scope&gt;test&lt;&#x2F;scope&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;
        &lt;version&gt;1.2.47&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
    &lt;!--RabbitMQ 依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;
</code></pre>

<p>3、创建 <code>application.yml</code> 文件</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:
  port: 8888
spring:
  rabbitmq:
    host: 192.168.91.200
    port: 5672
    username: root
    password: 123</code></pre>

<p>这里是 8808 端口，可根据需求决定端口</p>
<p>4、新建主启动类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication
public class RabbitmqSpringbootApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(RabbitmqSpringbootApplication.class, args);
    &#125;

&#125;</code></pre>

<h4 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h4><h5 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h5><p><img src="D:\imags\typora_imags\image-20230509225542592.png" alt="image-20230509225542592"></p>
<p>原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息</p>
<p><strong>构建关系</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class TtlQueueConfig &#123;

    &#x2F;&#x2F;普通交换机的名称
    public static final String X_EXCHANGE&#x3D;&quot;X&quot;;
    &#x2F;&#x2F;死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE&#x3D;&quot;Y&quot;;
    &#x2F;&#x2F;普通队列的名称
    public static final String QUEUE_A&#x3D;&quot;QA&quot;;
    public static final String QUEUE_B&#x3D;&quot;QB&quot;;
    &#x2F;&#x2F;死信队列的名称
    public static final String DEAD_LETTER_QUEUE&#x3D;&quot;QD&quot;;

    &#x2F;&#x2F;声明xExchange  别名
    @Bean(&quot;xExchange&quot;)
    public DirectExchange xExchange()&#123;
        return new DirectExchange(X_EXCHANGE);
    &#125;

    &#x2F;&#x2F;声明yExchange 别名
    @Bean(&quot;yExchange&quot;)
    public DirectExchange yExchange()&#123;
        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
    &#125;

    &#x2F;&#x2F;声明普通队列  要有ttl 为10s
    @Bean(&quot;queueA&quot;)
    public Queue queueA()&#123;
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;(3);
        &#x2F;&#x2F;设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE);
        &#x2F;&#x2F;设置死信RoutingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;);
        &#x2F;&#x2F;设置TTL 10s 单位是ms
        arguments.put(&quot;x-message-ttl&quot;,10000);
        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
    &#125;

    &#x2F;&#x2F;声明普通队列  要有ttl 为40s
    @Bean(&quot;queueB&quot;)
    public Queue queueB()&#123;
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;(3);
        &#x2F;&#x2F;设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE);
        &#x2F;&#x2F;设置死信RoutingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;);
        &#x2F;&#x2F;设置TTL 10s 单位是ms
        arguments.put(&quot;x-message-ttl&quot;,40000);
        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
    &#125;

    &#x2F;&#x2F;声明死信队列  要有ttl 为40s
    @Bean(&quot;queueD&quot;)
    public Queue queueD()&#123;
        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
    &#125;

    &#x2F;&#x2F;声明队列 QA 绑定 X 交换机
    @Bean
    public Binding queueABindingX(@Qualifier(&quot;queueA&quot;) Queue queueA,
                                  @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123;
        return BindingBuilder.bind(queueA).to(xExchange).with(&quot;XA&quot;);
    &#125;

    &#x2F;&#x2F;声明队列 QB 绑定 X 交换机
    @Bean
    public Binding queueBBindingX(@Qualifier(&quot;queueB&quot;) Queue queueB,
                                  @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123;
        return BindingBuilder.bind(queueB).to(xExchange).with(&quot;XB&quot;);
    &#125;

    &#x2F;&#x2F;声明队列 QD 绑定 Y 交换机
    @Bean
    public Binding queueDBindingY(@Qualifier(&quot;queueD&quot;) Queue queueD,
                                  @Qualifier(&quot;yExchange&quot;) DirectExchange yExchange)&#123;
        return BindingBuilder.bind(queueD).to(yExchange).with(&quot;YD&quot;);
    &#125;

&#125;</code></pre>

<p><strong>生产者</strong></p>
<p><strong>Controller 层代码，获取消息，放到 RabbitMQ</strong> 里</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;&#x2F;ttl&quot;)
public class SendMsgController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;
    &#x2F;&#x2F;开始发消息
    @GetMapping(&quot;&#x2F;sendMsg&#x2F;&#123;message&#125;&quot;)
    public void sendMsg(@PathVariable(&quot;message&quot;) String message)&#123;
        log.info(&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列：&#123;&#125;&quot;,new Date().toString(),message);
        &#x2F;*
        参数： 路由名称，路由key,message
        convertAndSend(…) 使用此方法，交换机会马上把所有的信息都交给所有的消费者，消费者再自行处理，
        不会因为消费者处理慢而阻塞线程。
        返回结果是：消息来自ttl为xx s的队列+message
        *&#x2F;
        rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XA&quot;,&quot;消息来自ttl为10s的队列:&quot;+message);
        rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XB&quot;,&quot;消息来自ttl为40s的队列:&quot;+message);
		
    &#125;
&#125;</code></pre>



<p><strong>测试</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">发起一个请求：http:&#x2F;&#x2F;localhost:8888&#x2F;ttl&#x2F;sendMsg&#x2F;嘻嘻嘻</code></pre>

<p><img src="D:\imags\typora_imags\image-20230511195931570.png" alt="image-20230511195931570"></p>
<p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>
<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL  为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
<h4 id="延时队列TTL优化"><a href="#延时队列TTL优化" class="headerlink" title="延时队列TTL优化"></a>延时队列TTL优化</h4><p>在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：</p>
<p><img src="D:\imags\typora_imags\image-20230511210128115.png" alt="image-20230511210128115"></p>
<p><strong>配置类代码</strong></p>
<p>新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class MsgTtlQueueConfig &#123;

    &#x2F;&#x2F;普通队列的名称
    public static final String QUEUE_C &#x3D; &quot;QC&quot;;

    &#x2F;&#x2F;死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE&#x3D;&quot;Y&quot;;

    &#x2F;&#x2F;声明QC
    @Bean(&quot;queueC&quot;)
    public Queue QueueC()&#123;
        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;(3);
        &#x2F;&#x2F;设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE);
        &#x2F;&#x2F;设置死信RoutingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;XC&quot;);
        return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();
    &#125;
    
    &#x2F;&#x2F;声明队列 QC 绑定 X 交换机
    @Bean
    public Binding queueCBindingX(@Qualifier(&quot;queueC&quot;) Queue queueC,
                                  @Qualifier(&quot;xExchange&quot;)DirectExchange xExchange)&#123;
        return BindingBuilder.bind(queueC).to(xExchange).with(&quot;XC&quot;);
    &#125;

&#125;</code></pre>

<p><strong>生产者</strong></p>
<p><strong>Controller 新增方法</strong></p>
<p>该方法接收的请求要带有 TTL 时间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;&#x2F;ttl&quot;)
public class SendMsgController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;
    &#x2F;&#x2F;开始发消息
    @GetMapping(&quot;&#x2F;sendMsg&#x2F;&#123;message&#125;&quot;)
    public void sendMsg(@PathVariable(&quot;message&quot;) String message)&#123;
        log.info(&quot;当前时间:&#123;&#125;,发送一条信息给两个TTL队列：&#123;&#125;&quot;,new Date().toString(),message);
        rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XA&quot;,&quot;消息来自ttl为10s的队列:&quot;+message);
        rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XB&quot;,&quot;消息来自ttl为40s的队列:&quot;+message);

    &#125;

    &#x2F;&#x2F;开始发消息 发TTL
    @GetMapping(&quot;&#x2F;sendExpirationMsg&#x2F;&#123;message&#125;&#x2F;&#123;ttlTime&#125;&quot;)
    public void sendMsg(@PathVariable(&quot;message&quot;) String message,
                        @PathVariable(&quot;ttlTime&quot;) String ttlTime)&#123;
        log.info(&quot;当前时间:&#123;&#125;,发送一条时长是&#123;&#125;毫秒TTL信息给队列QC：&#123;&#125;&quot;,
                new Date().toString(),ttlTime,message);
        rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XC&quot;,message,msg -&gt; &#123;
            &#x2F;&#x2F;发送消息的时候的延迟时长
            msg.getMessageProperties().setExpiration(ttlTime);
            return msg;
        &#125;);
    &#125;
&#125;</code></pre>

<p>重启下面，发送请求:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">http:&#x2F;&#x2F;localhost:8888&#x2F;ttl&#x2F;sendExpirationMsg&#x2F;你好1&#x2F;20000

http:&#x2F;&#x2F;localhost:8888&#x2F;ttl&#x2F;sendExpirationMsg&#x2F;你好2&#x2F;2000</code></pre>

<p><strong>出现问题</strong>:</p>
<p><img src="D:\imags\typora_imags\image-20230511210516564.png" alt="image-20230511210516564"></p>
<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」</p>
<blockquote>
<p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</p>
</blockquote>
<p>这也就是为什么如图的时间：你好 2 延时 2 秒，却后执行，还要等待你好 1 消费后再执行你好2</p>
<h4 id="RabbitMQ插件实现延迟队列"><a href="#RabbitMQ插件实现延迟队列" class="headerlink" title="RabbitMQ插件实现延迟队列"></a>RabbitMQ插件实现延迟队列</h4><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题</p>
<p><strong>安装延时队列插件</strong></p>
<p>可去 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">官网下载</a>  找到 <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p>
<p>因为官网也是跳转去该插件的 GitHub 地址进行下载：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">点击跳转</a></p>
<p>打开 Linux，用 <code>Xftp</code> 将插件放到 RabbitMQ 的安装目录下的 plgins 目录，</p>
<p>RabbitMQ 与其 plgins 目录默认分别位于</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># RabbitMQ 安装目录
cd &#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.8.8   
# RabbitMQ 的 plgins 所在目录
cd &#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.8.8&#x2F;plugins</code></pre>

<p>其中我的版本是 <code>/rabbitmq_server-3.8.8</code></p>
<p>进入目录后执行下面命令让该<strong>插件生效</strong>，然后<strong>重启 RabbitMQ</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
# 重启服务
systemctl restart rabbitmq-server</code></pre>

<p>效果如下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@master plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange
Enabling plugins on node rabbit@master:
rabbitmq_delayed_message_exchange
The following plugins have been configured:
  rabbitmq_delayed_message_exchange
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@master...
The following plugins have been enabled:
  rabbitmq_delayed_message_exchange

started 1 plugins.
[root@master plugins]# systemctl restart rabbitmq-server</code></pre>

<blockquote>
<p>解释</p>
<p>安装命令不能出现插件版本和后缀，如 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange-3.8.0.ez</code> 会报错</p>
<p>必须是 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，后面不允许填入版本和文件后缀</p>
</blockquote>
<p>打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件</p>
<p><img src="D:\imags\typora_imags\image-20230511211948844.png" alt="image-20230511211948844"></p>
<h4 id="插件实战"><a href="#插件实战" class="headerlink" title="插件实战"></a>插件实战</h4><p>在这里新增了一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下:</p>
<p><img src="D:\imags\typora_imags\image-20230511212109573.png" alt="image-20230511212109573"></p>
<p><strong>配置类代码</strong></p>
<p>新增一个配置类 <code>DelayedQueueConfig</code>，也可以放在原来的配置文件里，代码里使用了 <code>CustomExchange</code> 类，通过参数来自定义一个类型(direct、topic等)</p>
<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class DelayedQueueConfig &#123;

    &#x2F;&#x2F;交换机
    public static final String DELAYED_EXCHANGE_NAME &#x3D; &quot;delayed.exchange&quot;;
    &#x2F;&#x2F;队列
    public static final String DELAYED_QUEUE_NAME &#x3D; &quot;delayed.queue&quot;;
    &#x2F;&#x2F;routingKey
    public static final String DELAYED_ROUTING_KEY &#x3D; &quot;delayed.routingkey&quot;;


    @Bean
    public Queue delayedQueue()&#123;
        return new Queue(DELAYED_QUEUE_NAME);
    &#125;

    &#x2F;&#x2F;声明交换机,基于插件的交换机
    @Bean
    public CustomExchange delayedExchange()&#123;

        Map&lt;String,Object&gt; arguments &#x3D; new HashMap&lt;&gt;();
        arguments.put(&quot;x-delayed-type&quot;,&quot;direct&quot;);
        &#x2F;**
         * 1.交换机的名称
         * 2.交换机的类型 x-delayed-message
         * 3.是否需要持久化
         * 4.是否需要自动删除
         * 5.其他的参数
         *&#x2F;
        return new CustomExchange(DELAYED_EXCHANGE_NAME,&quot;x-delayed-message&quot;,
                true,false,arguments);
    &#125;

    &#x2F;&#x2F;绑定
    @Bean
    public Binding delayedQueueBindingDelayedExchange(
            @Qualifier(&quot;delayedQueue&quot;) Queue delayedQueue,
            @Qualifier(&quot;delayedExchange&quot;)CustomExchange delayedExchange)&#123;
        return BindingBuilder.bind(delayedQueue).to(delayedExchange)
                .with(DELAYED_ROUTING_KEY).noargs();
    &#125;
&#125;</code></pre>

<p><strong>生产者代码</strong></p>
<p>在 controller 里新增一个方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;开始发消息，基于插件的 消息及 延迟的时间
@GetMapping(&quot;&#x2F;sendDelayMsg&#x2F;&#123;message&#125;&#x2F;&#123;delayTime&#125;&quot;)
public void sendMsg(@PathVariable(&quot;message&quot;) String message,
                    @PathVariable(&quot;delayTime&quot;) Integer delayTime)&#123;
    log.info(&quot;当前时间:&#123;&#125;,发送一条时长是&#123;&#125;毫秒TTL信息给延迟队列delayed.queue：&#123;&#125;&quot;,
            new Date().toString(),delayTime,message);

    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,
            DelayedQueueConfig.DELAYED_ROUTING_KEY,message, msg -&gt; &#123;
        &#x2F;&#x2F;发送消息的时候的延迟时长 单位ms
        msg.getMessageProperties().setDelay(delayTime);
        return msg;
    &#125;);
&#125;</code></pre>

<p><strong>消费者代码</strong></p>
<p>监听延时队列，如果有消息进入该队列，则打印到控制台</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@Component
public class DelayQueueConsumer &#123;

    @RabbitListener(queues &#x3D; DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message)&#123;
        String msg &#x3D; new String(message.getBody());
        log.info(&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;, new Date().toString(), msg);
    &#125;
&#125;</code></pre>

<p><strong>测试</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;localhost:8888&#x2F;ttl&#x2F;sendDelayMsg&#x2F;hello1&#x2F;20000

http:&#x2F;&#x2F;localhost:8888&#x2F;ttl&#x2F;sendDelayMsg&#x2F;hello2&#x2F;2000</code></pre>

<p><img src="D:\imags\typora_imags\image-20230511212626180.png" alt="image-20230511212626180"></p>
<p>可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1</p>
<h3 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h3><p>在<strong>生产环境中由于一些不明原因，导致 RabbitMQ 重启</strong>，<strong>在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong>。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？</p>
<h4 id="发布确认SpringBoot版本"><a href="#发布确认SpringBoot版本" class="headerlink" title="发布确认SpringBoot版本"></a>发布确认SpringBoot版本</h4><p>简单的发布确认机制在应答与签收已经介绍，本内容将介绍整合了 SpringBoot 的发布确认机制。</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>首先<strong>发布消息后进行备份在缓存</strong>里，如果<strong>消息成功发布确认到交换机，则从缓存里删除该消息，如果没有成功发布，则设置一个定时任务，重新从缓存里获取消息发布到交换机，直到成功发布到交换机</strong>。</p>
<p><img src="D:\imags\typora_imags\image-20230511213702967.png" alt="image-20230511213702967"></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>一个交换机：confirm.exchange，一个队列：confirm.queue，一个消费者：confirm.consumer</p>
<p>其中交换机类型时 direct，与队列关联的 routingKey 是 key1</p>
<p>代码架构图：</p>
<p><img src="D:\imags\typora_imags\image-20230511213929024.png" alt="image-20230511213929024"></p>
<p>在配置文件当中需要添加：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:
  port: 8888
spring:
  rabbitmq:
    host: 192.168.91.200
    port: 5672
    username: root
    password: 123
    publisher-confirm-type: correlated</code></pre>
<p>publisher-confirm-type</p>
<ul>
<li><code>NONE</code> 值是禁用发布确认模式，是默认值</li>
<li><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</li>
<li><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用  waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker  节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭  channel，则接下来无法发送消息到 broker;</li>
</ul>
<p><strong>添加配置类</strong></p>
<p>声明交换机和队列，并且将交换机和队列进行绑定</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class ConfirmConfig &#123;

    &#x2F;&#x2F;交换机
    public static final String CONFIRM_EXCHANGE_NAME &#x3D; &quot;confirm_exchange&quot;;
    &#x2F;&#x2F;队列
    public static final String CONFIRM_QUEUE_NAME &#x3D; &quot;confirm_queue&quot;;
    &#x2F;&#x2F;routingKey
    public static final String CONFIRM_ROUTING_KEY &#x3D; &quot;key1&quot;;

    &#x2F;&#x2F;声明交换机
    @Bean(&quot;confirmExchange&quot;)
    public DirectExchange confirmExchange()&#123;
        return new DirectExchange(CONFIRM_EXCHANGE_NAME);
    &#125;

    &#x2F;&#x2F;声明队列
    @Bean(&quot;confirmQueue&quot;)
    public Queue confirmQueue()&#123;
        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();
    &#125;

    &#x2F;&#x2F;绑定
    @Bean
    public Binding queueBindingExchange(@Qualifier(&quot;confirmQueue&quot;) Queue confirmQueue,
                                        @Qualifier(&quot;confirmExchange&quot;) DirectExchange confirmExchange)&#123;
        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);
    &#125;
&#125;</code></pre>



<p><strong>消息生产者</strong></p>
<p>也可以说是 Controller 层</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@RequestMapping(&quot;&#x2F;confirm&quot;)
@RestController
public class ProductController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    &#x2F;&#x2F;开始发消息,测试确认
    @GetMapping(&quot;&#x2F;sendMessage&#x2F;&#123;message&#125;&quot;)
    public void sendMessage(@PathVariable(&quot;message&quot;) String message)&#123;
        &#x2F;&#x2F;指定消息 id 为 1
        CorrelationData correlationData1 &#x3D; new CorrelationData(&quot;1&quot;);
        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,
                ConfirmConfig.CONFIRM_ROUTING_KEY,message+&quot;key1&quot;,correlationData1);
        log.info(&quot;发送消息内容:&#123;&#125;&quot;,message+&quot;key1&quot;);

        &#x2F;&#x2F;指定消息 id 为 2
        CorrelationData correlationData2 &#x3D; new CorrelationData(&quot;2&quot;);
        String CONFIRM_ROUTING_KEY &#x3D; &quot;key2&quot;;
        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,
                CONFIRM_ROUTING_KEY,message+&quot;key2&quot;,correlationData2);
        log.info(&quot;发送消息内容:&#123;&#125;&quot;,message+&quot;key2&quot;);
    &#125;

&#125;</code></pre>

<p><strong>消息消费者</strong></p>
<p>监听 <code>confirm.queue</code> 队列</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@Component
public class Consumer &#123;

    @RabbitListener(queues &#x3D; ConfirmConfig.CONFIRM_QUEUE_NAME)
    public void receiveConfirmMessage(Message message)&#123;
        String msg &#x3D; new String(message.getBody());
        log.info(&quot;接受到的队列confirm.queue消息:&#123;&#125;&quot;,msg);
    &#125;
&#125;</code></pre>

<p><strong>消息生产者发布消息后的回调接口</strong></p>
<p>只要生产者发布消息，交换机不管是否收到消息，都会调用该类的 <code>confirm</code> 方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 回调接口
 *&#x2F;
@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback &#123;

    &#x2F;&#x2F;注入
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init()&#123;
        &#x2F;&#x2F;注入
        rabbitTemplate.setConfirmCallback(this);
    &#125;
    &#x2F;**
     * 交换机不管是否收到消息的一个回调方法
     * 1. 发消息 交换机接收到了 回调
     * @param correlationData  保存回调信息的Id及相关信息
     * @param ack              交换机收到消息 为true
     * @param cause            未收到消息的原因
     *
     *&#x2F;
    @Override
    public void confirm(CorrelationData correlationData, boolean ack,String cause) &#123;
        String id &#x3D; correlationData!&#x3D;null?correlationData.getId():&quot;&quot;;
        if(ack)&#123;
            log.info(&quot;交换机已经收到了ID为:&#123;&#125;的消息&quot;,id);
        &#125;else &#123;
            log.info(&quot;交换机还未收到ID为:&#123;&#125;的消息，由于原因:&#123;&#125;&quot;,id,cause);
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>测试</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http:&#x2F;&#x2F;localhost:8888&#x2F;confirm&#x2F;sendMessage&#x2F;大家好1</code></pre>

<p>结果分析:</p>
<p><img src="D:\imags\typora_imags\image-20230511220439604.png" alt="image-20230511220439604"></p>
<p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为  “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为<strong>第二条消息的 RoutingKey 与队列的  BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了</strong>。</p>
<p>丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败。</p>
<h4 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h4><p><strong>介绍</strong></p>
<p>获取回退的消息，首先在配置文件开启该功能，然后需要自定义类实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并且初始化时，使用该自定义类作为回退消息的处理类，同时开启 <code>Mandatory</code>，设置为 true</p>
<p>在启动开启 Mandatory，或者在代码里手动开启 Mandatory 参数，或者都开启</p>
<p><strong>开启方式两种：</strong></p>
<p>配置类文件开启：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 新版
spring:
  rabbitmq:
  	template:
      mandatory: true
      
# 旧版
spring:
  rabbitmq:
    mandatory: true</code></pre>

<p>代码中开启:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">rabbitTemplate.setMandatory(true);</code></pre>



<p>上面“实战”概述</p>
<p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p>
<p>“回退消息”解决方案</p>
<p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><p>修改配置文件</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
    rabbitmq:
        host: 192.168.91.200
        port: 5672
        username: root
        password: 123
        publisher-confirm-type: correlated
        publisher-returns: true
        template:
            mandatory: true
server:
    port: 8888</code></pre>

<p><strong>修改回调接口</strong></p>
<p>实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并实现方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 回调接口
 *&#x2F; 
@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;

    &#x2F;&#x2F;注入
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init()&#123;
        &#x2F;&#x2F;注入
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setReturnsCallback(this);
    &#125;
    &#x2F;**
     * 交换机不管是否收到消息的一个回调方法
     * 1. 发消息 交换机接收到了 回调
     * @param correlationData  保存回调信息的Id及相关信息
     * @param ack              交换机收到消息 为true
     * @param cause            未收到消息的原因
     *
     *&#x2F;
    @Override
    public void confirm(CorrelationData correlationData, boolean ack,String cause) &#123;
        String id &#x3D; correlationData!&#x3D;null?correlationData.getId():&quot;&quot;;
        if(ack)&#123;
            log.info(&quot;交换机已经收到了ID为:&#123;&#125;的消息&quot;,id);
        &#125;else &#123;
            log.info(&quot;交换机还未收到ID为:&#123;&#125;的消息，由于原因:&#123;&#125;&quot;,id,cause);
        &#125;
    &#125;


    &#x2F;&#x2F;可以在当消息传递过程中不可达目的地时将消息返回给生产者
    &#x2F;&#x2F;只有不可达目的地的时候 才进行回退
    &#x2F;**
     * 当消息无法路由的时候的回调方法
     *  message      消息
     *  replyCode    编码
     *  replyText    退回原因
     *  exchange     从哪个交换机退回
     *  routingKey   通过哪个路由 key 退回
     *&#x2F;
    @Override
    public void returnedMessage(ReturnedMessage returned) &#123;
        log.error(&quot;消息&#123;&#125;,被交换机&#123;&#125;退回，退回原因:&#123;&#125;,路由key:&#123;&#125;&quot;,
                new String(returned.getMessage().getBody()),returned.getExchange(),
                returned.getReplyText(),returned.getRoutingKey());
    &#125;
&#125;</code></pre>



<p><strong>测试</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">打开浏览器访问地址：http:&#x2F;&#x2F;localhost:8888&#x2F;confirm&#x2F;sendMessage&#x2F;大家好1 </code></pre>

<p><img src="D:\imags\typora_imags\image-20230511232548563.png" alt="image-20230511232548563"></p>
<h4 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>有了 mandatory  参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>
<p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p>
<p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ  中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>
<h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><p>需要一个备份交换机 <code>backup.exchange</code>，类型为 <code>fanout</code>，该交换机发送消息到队列 <code>backup.queue</code> 和 <code>warning.queue</code></p>
<p>代码结构图:</p>
<p><img src="D:\imags\typora_imags\image-20230512100041867.png" alt="image-20230512100041867"></p>
<p><strong>配置类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @author frx
 * @version 1.0
 * @date 2022&#x2F;7&#x2F;26  19:05
 * desc：配置类，发布确认(高级)
 *&#x2F;
@Configuration
public class ConfirmConfig &#123;

    &#x2F;&#x2F;交换机
    public static final String CONFIRM_EXCHANGE_NAME &#x3D; &quot;confirm_exchange&quot;;
    &#x2F;&#x2F;队列
    public static final String CONFIRM_QUEUE_NAME &#x3D; &quot;confirm_queue&quot;;
    &#x2F;&#x2F;routingKey
    public static final String CONFIRM_ROUTING_KEY &#x3D; &quot;key1&quot;;

    &#x2F;&#x2F;关于备份的
    &#x2F;&#x2F;交换机
    public static final String BACKUP_EXCHANGE_NAME &#x3D; &quot;backup_exchange&quot;;
    &#x2F;&#x2F;队列
    public static final String BACKUP_QUEUE_NAME &#x3D; &quot;backup_queue&quot;;
    &#x2F;&#x2F;报警队列
    public static final String WARNING_QUEUE_NAME &#x3D; &quot;warning_queue&quot;;


    &#x2F;&#x2F;声明交换机,设置该交换机的备份交换机
    @Bean(&quot;confirmExchange&quot;)
    public DirectExchange confirmExchange()&#123;
        return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)
                .durable(true).withArgument(&quot;alternate-exchange&quot;,BACKUP_EXCHANGE_NAME).build();
    &#125;

    &#x2F;&#x2F;声明队列
    @Bean(&quot;confirmQueue&quot;)
    public Queue confirmQueue()&#123;
        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();
    &#125;

    &#x2F;&#x2F;绑定
    @Bean
    public Binding queueBindingExchange(@Qualifier(&quot;confirmQueue&quot;) Queue confirmQueue,
                                        @Qualifier(&quot;confirmExchange&quot;) DirectExchange confirmExchange)&#123;
        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);
    &#125;

    &#x2F;&#x2F;备份交换机的创建
    @Bean(&quot;backupExchange&quot;)
    public FanoutExchange backupExchange()&#123;
        return new FanoutExchange(BACKUP_EXCHANGE_NAME);
    &#125;

    &#x2F;&#x2F;声明备份队列
    @Bean(&quot;backupQueue&quot;)
    public Queue backupQueue()&#123;
        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();
    &#125;

    &#x2F;&#x2F;声明报警队列
    @Bean(&quot;warningQueue&quot;)
    public Queue warningQueue()&#123;
        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();
    &#125;

    &#x2F;&#x2F;绑定 备份队列绑定备份交换机
    @Bean
    public Binding backupQueueBindingBackupExchange(@Qualifier(&quot;backupQueue&quot;) Queue backupQueue,
                                        @Qualifier(&quot;backupExchange&quot;) FanoutExchange backupExchange)&#123;
        return BindingBuilder.bind(backupQueue).to(backupExchange);
    &#125;

    &#x2F;&#x2F;绑定 报警队列绑定备份交换机
    @Bean
    public Binding warningQueueBindingBackupExchange(@Qualifier(&quot;warningQueue&quot;) Queue warningQueue,
                                                    @Qualifier(&quot;backupExchange&quot;) FanoutExchange backupExchange)&#123;
        return BindingBuilder.bind(warningQueue).to(backupExchange);
    &#125;

&#125;</code></pre>

<p><strong>报警消费者</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 报警消费者
 *&#x2F;
@Slf4j
@Component
public class WarningConsumer &#123;

    &#x2F;&#x2F;接收报警信息
    @RabbitListener(queues &#x3D; ConfirmConfig.WARNING_QUEUE_NAME)
    public void receiveWarningMsg(Message message)&#123;
        String msg &#x3D; new String(message.getBody());
        log.error(&quot;报警发现不可路由消息:&#123;&#125;&quot;,msg);
    &#125;
&#125;</code></pre>

<p>由于之前写过 <code>confirm.exchange</code> 交换机，当更改配置了，需要删掉，不然会报错</p>
<p><img src="D:\imags\typora_imags\image-20230512104416205.png" alt="image-20230512104416205"></p>
<p>Mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>
<h3 id="RabbitMQ-其他知识点"><a href="#RabbitMQ-其他知识点" class="headerlink" title="RabbitMQ 其他知识点"></a>RabbitMQ 其他知识点</h3><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</p>
<p>可以理解为验证码，只能输入一次，再次重新输入会刷新验证码，原来的验证码失效。</p>
<h5 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h5><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ  未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>MQ 消费者的幂等性的解决一般使用<strong>全局 ID <strong>或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，</strong>每次消费消息时用该 id 先判断该消息是否已消费过</strong></p>
<h5 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h5><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<p>业界主流的幂等性有两种操作：</p>
<ul>
<li>唯一 ID+ 指纹码机制,利用数据库主键去重</li>
</ul>
<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id  是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<ul>
<li>Redis 的原子性</li>
</ul>
<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>
<p>但是，tmall  商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List  做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ  进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<h5 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h5><p><strong>Web页面添加</strong></p>
<ol>
<li>进入 Web 页面，点击 Queue 菜单，然后点击 <code>Add a new queue</code></li>
<li>点击下方的 <code>Maximum priority</code></li>
<li>执行第二步，则会自动在 <code>Argument</code> 生成 <code>x-max-priority</code> 字符串</li>
<li>点击 <code>Add queue</code> 即可添加优先级队列成功</li>
</ol>
<p><img src="D:\imags\typora_imags\image-20230512112423411.png" alt="image-20230512112423411"></p>
<p><strong>声明队列时添加优先级</strong></p>
<p>设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String, Object&gt; params &#x3D; new HashMap();
&#x2F;&#x2F; 优先级为 10
params.put(&quot;x-max-priority&quot;, 10);
channel.queueDeclare(&quot;hello&quot;, true, false, false, params);</code></pre>

<p>注意</p>
<blockquote>
<p>注意事项</p>
<p>队列实现优先级需要做的事情有如下：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</p>
</blockquote>
<h5 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h5><p>生产者发送十个消息，如果消息为 <code>info5</code>，则优先级是最高的，当消费者从队列获取消息的时候，优先获取 <code>info5</code> 消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 优先级 生产者
 *&#x2F;
public class PriorityProducer &#123;

    private static final String QUEUE_NAME &#x3D; &quot;priority_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;给消息赋予一个priority属性
        AMQP.BasicProperties properties &#x3D;
                new AMQP.BasicProperties().builder().priority(1).priority(10).build();

        for (int i &#x3D; 1; i &lt; 11; i++) &#123;
            String message &#x3D; &quot;info&quot;+i;
            if(i&#x3D;&#x3D;5)&#123;
                channel.basicPublish(&quot;&quot;,QUEUE_NAME,properties,message.getBytes());
            &#125;else &#123;
                channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());
            &#125;
            System.out.println(&quot;消息发送完成：&quot;+message);
        &#125;
    &#125;
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 优先级 消费者
 *&#x2F;
public class PriorityConsumer &#123;

    private final static String QUEUE_NAME &#x3D; &quot;priority_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();

        &#x2F;&#x2F;设置队列的最大优先级 最大可以设置到255 官网推荐1-10 如果设置太高比较吃内存和CPU
        Map&lt;String, Object&gt; params &#x3D; new HashMap&lt;&gt;();
        params.put(&quot;x-max-priority&quot;,10);
        channel.queueDeclare(QUEUE_NAME,true,false,false,params);

        &#x2F;&#x2F;推送消息如何进行消费的接口回调
        DeliverCallback deliverCallback &#x3D; (consumerTag, delivery) -&gt;&#123;
            String message &#x3D; new String(delivery.getBody());
            System.out.println(&quot;消费的消息: &quot;+message);
        &#125;;

        &#x2F;&#x2F;取消消费的一个回调接口 如在消费的时候队列被删除掉了
        CancelCallback cancelCallback &#x3D; (consumerTag) -&gt;&#123;
            System.out.println(&quot;消息消费被中断&quot;);
        &#125;;

        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);
    &#125;
&#125;</code></pre>

<p><strong>效果</strong></p>
<p>nfo 5 的优先级为 10，优先级最高。消费者消费信息效果如图：</p>
<p><img src="D:\imags\typora_imags\image-20230513101236462.png" alt="image-20230513101236462"></p>
<h4 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h4><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><pre><code>    RabbitMQ 从 3.6.0  版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够**支持更长的队列，即支持更多的消息存储**。当**消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了**。



    默认情况下，当生产者将消息发送到 RabbitMQ  的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会**耗费较长的时间，也会阻塞队列的操作**，进而无法接收新的消息。虽然  RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。
</code></pre>
<h5 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h5><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 <code>channel.queueDeclare</code> 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过 <code>x-queue-mode</code> 参数来设置队列的模式，取值为 default 和 lazy。下面示例中演示了一个惰性队列的声明细节：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String, Object&gt; args &#x3D; new HashMap&lt;String, Object&gt;();
args.put(&quot;x-queue-mode&quot;, &quot;lazy&quot;);
channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</code></pre>



<p>也可以在 Web 页面添加队列时，选择 <code>Lazy mode</code></p>
<h5 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h5><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="clhldf9g7000kgspucucc7sqb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/MQ/" rel="tag">MQ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2023-05-04T11:52:49.000Z" itemprop="datePublished">2023-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">【设计模式】23 种设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设置模式介绍"><a href="#设置模式介绍" class="headerlink" title="设置模式介绍"></a>设置模式介绍</h2><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p>
<p>1） <strong>开发人员的共同平台</strong></p>
<p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，<strong>这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</strong></p>
<p>2）<strong>最佳的实践</strong></p>
<p>设计模式已经经历了很长一段时间的发展，<strong>它们提供了软件开发过程中面临的一般问题的最佳解决方案</strong>。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p>
<h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时<br>隐藏创建逻辑的方式，而不是使用 new 运算<br/>符直接实例化对象。这使得程序在判断针对<br/>某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式（Factory Pattern）</strong> <br> 抽象工厂模式（Abstract Factory Pattern）<br> <strong>单例模式（Singleton Pattern）</strong><br><strong>建造者模式（Builder Pattern）</strong> <br> 原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>结构型模式</strong><br> 这些设计模式关注类和对象的组合。继承的<br/>概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left">适配器模式（Adapter Pattern）<br> 桥接模式（Bridge Pattern）<br> 过滤器模式（Filter、Criteria Pattern） <br>组合模式（Composite Pattern）<br> 装饰器模式（Decorator Pattern）<br> 外观模式（Facade Pattern）<br> 享元模式（Flyweight Pattern）<br> <strong>代理模式（Proxy Pattern）</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>行为型模式</strong><br> 这些设计模式特别关注对象之间的通信。</td>
<td align="left">责任链模式（Chain of Responsibility Pattern） <br>命令模式（Command Pattern）<br> 解释器模式（Interpreter Pattern） <br>迭代器模式（Iterator Pattern）<br> 中介者模式（Mediator Pattern）<br> 备忘录模式（Memento Pattern）<br> <strong>观察者模式（Observer Pattern）</strong><br> 状态模式（State Pattern）<br> 空对象模式（Null Object Pattern）<br> <strong>策略模式（Strategy Pattern）</strong><br> 模板模式（Template Pattern）<br> 访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。<br/>这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left"><strong>MVC 模式（MVC Pattern）</strong><br> 业务代表模式（Business Delegate Pattern）<br> 组合实体模式（Composite Entity Pattern）<br> 数据访问对象模式（Data Access Object Pattern）<br> <strong>前端控制器模式（Front Controller Pattern）</strong><br> <strong>拦截过滤器模式（Intercepting Filter Pattern）</strong><br> 服务定位器模式（Service Locator Pattern）<br> 传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。<strong>在程序需要进行拓展的时候，不能去修改原有的代码</strong>，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则是面向对象设计的基本原则之一。<strong>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现</strong>。LSP  是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。<strong>实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现</strong>，所以<strong>里氏代换原则是对实现抽象化的具体步骤的规范。</strong></p>
<h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<h4 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h4><p>这个原则的意思是：<strong>使用多个隔离的接口，比使用单个接口要好</strong>。它还有另外一个意思是：<strong>降低类之间的耦合度</strong>。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<h4 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a>5、迪米特法则，又称最少知道原则（Demeter Principle）</h4><p>最少知道原则是指：一个<strong>实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</strong>。</p>
<h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>合成复用原则是指：尽量使用<strong>合成/聚合的方式，而不是使用继承</strong>。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过<strong>使用一个共同的接口来指向新创建的对象</strong>。</p>
<p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>优点：</strong></p>
<p> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 </p>
<p> 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>
<p> 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong></p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>使用场景：</strong> </p>
<p> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</p>
<p> 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p>
<p> 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何<strong>需要生成复杂对象的地方，都可以使用工厂方法模式。</strong>有一点需要注意的地方就是复杂对象适合使用工厂模式，而<strong>简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式</strong>。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。</p>
<p>下一步是定义工厂类 <em>ShapeFactory</em>。</p>
<p><em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。<em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504213909572.png"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 图形
 *&#x2F;
public interface Shape &#123;
   void draw();
&#125;</code></pre>

<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形
 *&#x2F;
public class Rectangle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 正方形
 *&#x2F;
public class Square implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 圆形
 *&#x2F;
public class Circle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class ShapeFactory &#123;
    
   &#x2F;&#x2F;使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType)&#123;
      if(shapeType &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;
         return new Circle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;
         return new Rectangle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;
         return new Square();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>

<p><strong>步骤4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FactoryPatternDemo &#123;
 
   public static void main(String[] args) &#123;
      ShapeFactory shapeFactory &#x3D; new ShapeFactory();
 
      &#x2F;&#x2F;获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);
      &#x2F;&#x2F;调用 Circle 的 draw 方法
      shape1.draw();
 
      &#x2F;&#x2F;获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);
      &#x2F;&#x2F;调用 Rectangle 的 draw 方法
      shape2.draw();
 
      &#x2F;&#x2F;获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);
      &#x2F;&#x2F;调用 Square 的 draw 方法
      shape3.draw();
   &#125;
&#125;
</code></pre>

<p><strong>步骤 5</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.</code></pre>



<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。</p>
<p>下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。</p>
<p>然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p>
<p><em>AbstractFactoryPatternDemo</em> 类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504224216544.png"></p>
<p><strong>步骤1</strong></p>
<p>为形状创建一个接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Shape &#123;
   void draw();
&#125;</code></pre>



<p><strong>步骤2</strong></p>
<p>创建实现接口的实体类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形状
 *&#x2F;
public class Rectangle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形状
 *&#x2F;
public class Square implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 圆形
 *&#x2F;
public class Circle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>



<p><strong>步骤3</strong></p>
<p>为颜色创建一个接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Color &#123;
   void fill();
&#125;</code></pre>



<p><strong>步骤4</strong></p>
<p>创建实现接口的实体类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Red implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Red::fill() method.&quot;);
   &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Green implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Green::fill() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Blue implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Blue::fill() method.&quot;);
   &#125;
&#125;
</code></pre>



<p><strong>步骤5</strong></p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractFactory &#123;
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
&#125;</code></pre>



<p><strong>步骤6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShapeFactory extends AbstractFactory &#123;
    
   @Override
   public Shape getShape(String shapeType)&#123;
      if(shapeType &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;
         return new Circle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;
         return new Rectangle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;
         return new Square();
      &#125;
      return null;
   &#125;
   
   @Override
   public Color getColor(String color) &#123;
      return null;
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ColorFactory extends AbstractFactory &#123;
    
   @Override
   public Shape getShape(String shapeType)&#123;
      return null;
   &#125;
   
   @Override
   public Color getColor(String color) &#123;
      if(color &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;
         return new Red();
      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;
         return new Green();
      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;
         return new Blue();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>



<p><strong>步骤7</strong></p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FactoryProducer &#123;
   public static AbstractFactory getFactory(String choice)&#123;
      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;
         return new ShapeFactory();
      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;
         return new ColorFactory();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>



<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class AbstractFactoryPatternDemo &#123;
   public static void main(String[] args) &#123;
 
      &#x2F;&#x2F;获取形状工厂
      AbstractFactory shapeFactory &#x3D; FactoryProducer.getFactory(&quot;SHAPE&quot;);
      
       &#x2F;&#x2F;获取形状为 Circle 的对象
      Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);
      &#x2F;&#x2F;调用 Circle 的 draw 方法
      shape1.draw();
 
      &#x2F;&#x2F;获取形状为 Rectangle 的对象
      Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);
      &#x2F;&#x2F;调用 Rectangle 的 draw 方法
      shape2.draw();
       
      &#x2F;&#x2F;获取形状为 Square 的对象
      Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);
      &#x2F;&#x2F;调用 Square 的 draw 方法
      shape3.draw();
 
      &#x2F;&#x2F;获取颜色工厂
      AbstractFactory colorFactory &#x3D; FactoryProducer.getFactory(&quot;COLOR&quot;);
      
       &#x2F;&#x2F;获取颜色为 Red 的对象
      Color color1 &#x3D; colorFactory.getColor(&quot;RED&quot;);
      &#x2F;&#x2F;调用 Red 的 fill 方法
      color1.fill();
       
      &#x2F;&#x2F;获取颜色为 Green 的对象
      Color color2 &#x3D; colorFactory.getColor(&quot;GREEN&quot;);
      &#x2F;&#x2F;调用 Green 的 fill 方法
      color2.fill();
 
      &#x2F;&#x2F;获取颜色为 Blue 的对象
      Color color3 &#x3D; colorFactory.getColor(&quot;BLUE&quot;);
      &#x2F;&#x2F;调用 Blue 的 fill 方法
      color3.fill();
   &#125;
&#125;
</code></pre>



<p><strong>步骤9</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.</code></pre>



<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。 </li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>SingleObject</em> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。 </p>
<p><em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo</em> 类使用 <em>SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504230436259.png"></p>
<p>下面实现为饿汉式，线程安全。</p>
<p><strong>步骤1</strong></p>
<p>创建一个 Singleton 类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SingleObject &#123;
 
   &#x2F;&#x2F;创建 SingleObject 的一个对象
   private static SingleObject instance &#x3D; new SingleObject();
 
   &#x2F;&#x2F;让构造函数为 private，这样该类就不会被实例化
   private SingleObject()&#123;&#125;
 
   &#x2F;&#x2F;获取唯一可用的对象
   public static SingleObject getInstance()&#123;
      return instance;
   &#125;
 
   public void showMessage()&#123;
      System.out.println(&quot;Hello World!&quot;);
   &#125;
&#125;</code></pre>



<p><strong>步骤2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SingletonPatternDemo &#123;
   public static void main(String[] args) &#123;
 
      &#x2F;&#x2F;不合法的构造函数
      &#x2F;&#x2F;编译时错误：构造函数 SingleObject() 是不可见的
      &#x2F;&#x2F;SingleObject object &#x3D; new SingleObject();
 
      &#x2F;&#x2F;获取唯一可用的对象
      SingleObject object &#x3D; SingleObject.getInstance();
 
      &#x2F;&#x2F;显示消息
      object.showMessage();
   &#125;
&#125;
</code></pre>



<p><strong>步骤 3</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Hello World!</code></pre>



<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><p>最近找工作忙死，晚点更新……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clhldf9gt000zgspu38bj2yvu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【nigix】反向代理与负载均衡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/04/%E3%80%90nigix%E3%80%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="article-date">
  <time datetime="2023-05-04T10:14:28.000Z" itemprop="datePublished">2023-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/nginx/">nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/04/%E3%80%90nigix%E3%80%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">【nginx】反向代理与负载均衡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx同Apache一样都是一种WEB服务器，基于REST架构风格，以统一资源描述符(Uniform Resources  Identifier)URI或者统一资源定位符(Uniform Resources  Locator)URL作为沟通依据，通过HTTP协议提供各种网络服务。</p>
<p>　　然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个WEB服务器有着各自鲜明的特点。</p>
<p>　　Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。它是不支持高并发的服务器。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。</p>
<p>　　这些都决定了Apache不可能成为高性能WEB服务器，轻量级高并发服务器Nginx就应运而生了。</p>
<p>　　俄罗斯的工程师Igor Sysoev，他在为Rambler Media工作期间，使用C语言开发了Nginx。Nginx作为WEB服务器一直为Rambler Media提供出色而又稳定的服务。</p>
<p>然后呢，Igor Sysoev将Nginx代码开源，并且赋予自由软件许可证。</p>
<h3 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h3><ul>
<li><p>Nginx使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接</p>
</li>
<li><p>高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊~）</p>
</li>
<li><p>Nginx是一个跨平台服务器，可以运行在Linux，Windows，FreeBSD，Solaris，AIX，Mac OS等操作系统上</p>
</li>
<li><p>极大的稳定性</p>
</li>
</ul>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504182123946.png"></p>
<h3 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h3><p>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网</p>
<p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>nginx 将服务器接收到的请求按照规则分发给服务器的过程，称为负载均衡。</p>
<h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p><strong>准备</strong>：（后续有空改为docker）</p>
<pre class="line-numbers language-none"><code class="language-none">虚拟机one：192.168.30.135:80

虚拟机two：192.168.30.128:80

两个虚拟机装的nginx都是：nginx version: nginx&#x2F;1.18.0</code></pre>



<p><strong>配置代理</strong></p>
<p>在各虚拟机上的conf.d文件夹下建立nginx配置文件，名字分别为：“xuniji_one.conf”、“xuniji_two.conf”</p>
<p>反向代理我写在了xuniji_one.conf中，如下图：</p>
<img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504183352473.png" style="zoom:67%;" />

<p>图中参数介绍：</p>
<ul>
<li>upstream后面的名称与proxy_pass后面的地址对应。（名称可以随意写）</li>
<li>upstream中的两个server地址就是两个服务器的地址。</li>
<li>proxy_pass：设置后端代理服务器的地址。这个地址(address)可以是一个域名或ip地址和端口，或者一个 unix-domain socket路径。</li>
<li>proxy_set_header：就是可设置请求头-并将头信息传递到服务器端。</li>
</ul>
<p><strong>测试</strong></p>
<p>打开浏览器，访问设置代理的服务器（<a target="_blank" rel="noopener" href="http://www.xuniji.one.com)./">www.xuniji.one.com）。</a> 每次访问最终都是请求不同的服务器。</p>
<img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504183640672.png" style="zoom:67%;" />



<h3 id="nginx的负载均衡策略"><a href="#nginx的负载均衡策略" class="headerlink" title="nginx的负载均衡策略"></a>nginx的负载均衡策略</h3><p>1、轮询（默认策略，nginx自带策略）：上面的例子就是轮询的方式，它是upstream模块默认的负载均衡默认策略。会将每个请求按时间顺序分配到不同的后端服务器。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        server 192.168.30.128:80;
        server 192.168.30.135:80;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;</code></pre>



<p>2、weight（权重，nginx自带策略）：指定轮询的访问几率，用于后端服务器性能不均时调整访问比例。权重越高，被分配的次数越多。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        server 192.168.30.128:80 weight&#x3D;7;
        server 192.168.30.135:80 weight&#x3D;2;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;</code></pre>



<p>3、p_hash（依据ip分配，nginx自带策略）：指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        ip_hash;
        server 192.168.30.128:80;
        server 192.168.30.135:80;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;</code></pre>



<p>4、least_conn（最少连接，nginx自带策略）：把请求转发给连接数较少的后端服务器。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        #把请求转发给连接数比较少的服务器
        least_conn;
        server 192.168.30.128:80;
        server 192.168.30.135:80;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;    </code></pre>



<p>5、fair（第三方）：按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        fair;
        server 192.168.30.128:80;
        server 192.168.30.135:80;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;   </code></pre>



<p>6、url_hash（第三方）：该策略按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，需要配合缓存用。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">http &#123;
    upstream xuniji_fuzai &#123;
        hash $request_uri;
        server 192.168.30.128:80;
        server 192.168.30.135:80;
    &#125;
  
    server &#123;
        listen 81;
        server_name www.xuniji.one.com;
  
        location &#x2F; &#123;
            proxy_pass http:&#x2F;&#x2F;xuniji_fuzai;
            proxy_set_header Host $proxy_host;
        &#125;
    &#125;
&#125;  </code></pre>







<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mklblog/p/16478798.html">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wcwnina/p/8728391.html">参考2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/04/%E3%80%90nigix%E3%80%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" data-id="clhldf9g9000pgspufqynggoy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【mysql】并发与事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/03/%E3%80%90mysql%E3%80%91%E5%B9%B6%E5%8F%91%E4%B8%8E%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2023-05-03T06:06:17.000Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/03/%E3%80%90mysql%E3%80%91%E5%B9%B6%E5%8F%91%E4%B8%8E%E4%BA%8B%E5%8A%A1/">【mysql】并发与事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事务（Transaction）及其-ACID属性"><a href="#事务（Transaction）及其-ACID属性" class="headerlink" title="事务（Transaction）及其 ACID属性"></a>事务（Transaction）及其 ACID属性</h3><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性</p>
<p><strong>原子性（Atomicity）</strong>:事务是一个原子操作单元，对其数据的修改，要么全都执行，要么全都不执行</p>
<p><strong>一致性（Consistent）</strong>: 在事务开始和完成时，数据必须保持一致状态。这意味着所有相关的数据都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有内部数据结构（如B树索引或双向链表）也都必须是正确的。</p>
<p><strong>隔离性(lsolation)</strong>: 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p>
<p><strong>持久性(Durable)</strong> : 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p>
<h3 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h3><ul>
<li><strong>更新丢失(Lost Update)</strong></li>
</ul>
<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。</p>
<p>例如，两个程序员修改同一iava文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</p>
<ul>
<li><strong>脏读(Dirty Reads)</strong></li>
</ul>
<p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态:这时，另一个事务也来读取同-条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象<br>被形象地叫做”脏读”。</p>
<p>一言以蔽之:事务读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p>
<ul>
<li><strong>不可重复读(Non-Repeatable Reads)</strong></li>
</ul>
<p>-个事务在速取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”。</p>
<p>一言以蔽之:事务A读取到了事务B已经提交的修改数据，不符合隔离性</p>
<ul>
<li><strong>幻读(Phantom Reads）</strong></li>
</ul>
<p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读“</p>
<p>一句话:事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<p>多说一句:幻读和脏读有点类似，不可重复读是事务B里面修改了数据，幻读是事务B里面新增了数据</p>
<h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><p>脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230501211344845.png"></p>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<br>

<p>查看当前数据库的事务隔离级别：（数据库的默认隔离级别为可重复读）</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># MYSQL5.7.2版本之前
show variables like &#39;tx_isolation&#39;;

# MYSQL5.7.2版本之后
show variables like &#39;transaction_isolation&#39;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/03/%E3%80%90mysql%E3%80%91%E5%B9%B6%E5%8F%91%E4%B8%8E%E4%BA%8B%E5%8A%A1/" data-id="clhldf9g6000igspuf70nd8my" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis工具类封装与解决缓存击穿，缓存穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/03/Redis%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" class="article-date">
  <time datetime="2023-05-03T03:10:29.000Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/05/03/Redis%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/">【Redis】工具类封装与解决缓存击穿，缓存穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@slf4j
@Component
public class CacheClient &#123;
    
    private final StringRedisTemplate stringRedisTemplate;
    
    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;
        this.stringRedisTemplate &#x3D; stringRedisTemplate;
    &#125;
    
    &#x2F;&#x2F; 创建10个线程的线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR &#x3D; Executors.newFixedThreadPool( nThreads: 10); 
    
    &#x2F;**
    * 设置普通的缓存
    *&#x2F;
    public void set(String key, Object value,Long time, TimeUnit unit) &#123;
       stringRedisTemplate.opsForValue().setIfAbsent(key, value: JSONUtil.toJsonStr(value), timeout: time, unit);
    &#125;
    
    &#x2F;**
    * 设置有逻辑过期的缓存
    *&#x2F;
    public void setwithLogicalExpire(String key, Object value, Long time, TimeUnit unit)&#123;
     	&#x2F;&#x2F; 设置逻辑过期
        RedisData redisata &#x3D; new RedisData();
        redisData.setData(value):
        redisData,setExpireTime(LocalDateTime,now().plusSeconds(unit,toSeconds(time)));
        &#x2F;&#x2F; 写入Redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value));   
    &#125;
    
    &#x2F;**
    * 基于缓存空对象，解决缓存穿透问题
    *&#x2F;
    public &lt;R,ID&gt; R queryWithPassThrough(
        String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFallback,Long time, TimeUnit unit
    ) &#123;
        String key &#x3D; keyPrefix + id;
         &#x2F;&#x2F; 从redis查询商铺缓存
        String json &#x3D; stringRedisTemplate.opsForValue().get(key);
         &#x2F;&#x2F; 判断是否存在
        if (StrUtil.isNotBlank(json)) &#123;&#x2F;&#x2F; json不能为null,不能为“”，不能为空格
         &#x2F;&#x2F; 存在，直接返回
          Shop shop &#x3D; JSONUtil.toBean(shopJson, type);
          return shop;   
         &#125;

        &#x2F;&#x2F;不存在，根据id查询数据库
        R r &#x3D; dbFallback.apply(id);
        &#x2F;&#x2F;不存在，返回错误
        if (r &#x3D;&#x3D; null) &#123;
             &#x2F;&#x2F; 将空值写入redis
            stringRedisTemplate.opsForValue().set(key, value: &quot;&quot; ,CACHE_NULL_TTL，TimeUnit.MINUTES);&#x2F;&#x2F; 返回错误信息
            return null;   
        &#125;

        &#x2F;&#x2F;存在，写入redis
        this.set(key, r, time, unit); 
        return shop;
   &#125;
    
    
    &#x2F;**
    * 基于逻辑过期方式，解决缓存击穿问题
    *&#x2F;
    public &lt;R,ID&gt; R queryWithLogicalExpire(
    String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFallback,Long time, TimeUnit unit
    ) &#123;
         String key &#x3D; keyPrefix + id;
        &#x2F;&#x2F;从redis查询商铺缓存
        String json &#x3D; stringRedisTemplate.opsForValue().get(key);
         &#x2F;&#x2F;是否命中
        if (StrUtil.isBlank(json)) &#123;&#x2F;&#x2F;shopJson能为null,不能为“”，能为空格
         &#x2F;&#x2F;存在，直接返回
          return null;   
         &#125;

        &#x2F;&#x2F;命中，判断是否缓存过期，需要将jsn反序列化为对象
        RedisData redisData &#x3D; JSONUtil.toBean(json,RedisData);
        R r &#x3D; JSONUtil.toBean((JsonObject)redisData.getData(),type);
        LocalDateTime expireTime &#x3D; data.getExpireTime();

        &#x2F;&#x2F;缓存未过期，直接返回店铺信息
        if(expireTime.isAfter(LocalDateTime.now()))&#123;
            return r; 
        &#125;

        &#x2F;&#x2F;过期，尝试获取互斥锁
        &#x2F;&#x2F;能获取互斥锁,没有资源在占用锁（获取锁,等于1说明没有人占用了）
        String lockKey &#x3D; LOCK_SHOP_KEY + id;
        boolean isLock &#x3D; tryLock(lockKey)；
        if(isLock))&#123;
             &#x2F;&#x2F;成功，开启独立线程，实现缓存重建
             CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;
                 try&#123;
                    &#x2F;&#x2F;重建缓存
                    R r &#x3D; dbFallback.apply(id);
                    &#x2F;&#x2F; 设置延迟为200s,模拟复制业务查询后的key
                    Thread.sleep(200); 
                    this.setwithLogicalExpire(key, r, time, unit);
                 &#125; catch (Exception e) &#123;
                    throw new RuntimeException(e) 
                 &#125; finally &#123;
                    &#x2F;&#x2F;释放锁
                     unlock(lockKey); 
                 &#125;
             &#125;)     
         &#125;

        &#x2F;&#x2F;返回过期数据
        return r;
	&#125;
    
    
    
    &#x2F;&#x2F; 获取锁
    private boolean tryLock(String key) [
        Boolean flag &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(key, value: &quot;1&quot;， timeout: 10, TimeUnit.SECONDS):
        return BooleanUtil.isTrue(flag);
    &#125;

    &#x2F;&#x2F; 释放锁
    private void unlock(String key) &#123;
        stringRedisTemplate.delete(key);
    &#125;
&#125;</code></pre>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123;
    @Resource
    private StringRedisTemplate stringRedisTemplate:
    @Resource
    private CacheClientcacheClient  
        
    @Override
    public Result queryById(Long id) &#123;
        &#x2F;&#x2F; 解决缓存穿透
        &#x2F;&#x2F;写法1
        Shop shop &#x3D; cacheclient.queryWithPassThrough(CACHE_SHOPKEY, id, Shop.class, id2 -&gt; getByid(id2), CACHE_SHOP_TTL，TimeUnit.MINUTES );
        &#x2F;&#x2F;写法2
       Shop shop &#x3D; cacheclient.queryWithPassThrough(CACHE_SHOPKEY, id, Shop.class, this::getById, CACHE_SHOP_TTL，TimeUnit.MINUTES );
       
        &#x2F;&#x2F; 互斥锁解决缓存击穿
        &#x2F;&#x2F; Shop shop &#x3D; queryWithMutex(id);
        
        &#x2F;&#x2F; 逻辑过期解决缓存击穿
        Shop shop &#x3D; cacheclient.queryWithLogicalExpire(CACHE_SHOPKEY,id,Shop.class,this::getById,CACHE_SHOP_TTL，TimeUnit.MINUTES);
        if (shop &#x3D;&#x3D; null) &#123;
            return Result.fail(&quot;店铺不存在!&quot;);
        &#125;
        &#x2F;&#x2F; 7.返回
        return Result.ok(shop);          
     &#125;
  
    
&#125;</code></pre>



<p>给id为1数据，先缓存预热（再缓存击穿）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
void testSaveShop() throws InterruptedException &#123;
    Shop shop &#x3D; shopService.getById(1L);
	cacheClient.setWithLogicalExpire( key: CACHE_SHOP_KEY + 1L, shop, 10L, TimeUnit,SECONDS);
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/03/Redis%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" data-id="clhldf9fk0001gspu2a5uacwr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/04/24/hello-world/" class="article-date">
  <time datetime="2023-04-24T05:22:44.927Z" itemprop="datePublished">2023-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/bk/2023/04/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><pre class="line-numbers language-java" data-language="java" data-start="1" data-line="5,6,7,8" data-line-offset="0"><code class="language-java">public class Producer &#123;
    &#x2F;&#x2F;普通交换机的名称
    public static final String NORMAL_EXCHANGE &#x3D; &quot;normal_exchange&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel &#x3D; RabbitMQUtils.getChannel();
    
        &#x2F;&#x2F;死信消息 设置ttl时间 live to time 单位是ms
        &#x2F;&#x2F;AMQP.BasicProperties properties &#x3D;
        &#x2F;&#x2F;        new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        for (int i &#x3D; 1; i &lt;11 ; i++) &#123;
            String message &#x3D; &quot;info&quot;+i;
            channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,null,message.getBytes());
        &#125;
    &#125;
&#125;
</code></pre>



<pre class="line-numbers language-none" data-start="1" data-line="" data-line-offset="0"><code class="language-none">alert(&#39;Hello World!&#39;);</code></pre>



<pre class="line-numbers language-none" data-start="1" data-line="" data-line-offset="0"><div class="caption"><span>_.compact</span><a target="_blank" rel="noopener" href="http://underscorejs.org/#compact">Underscore.js</a></div><code class="language-none">_.compact([0, 1, false, 2, &#39;&#39;, 3]);
&#x3D;&gt; [1, 2, 3]</code></pre>



<pre class="line-numbers language-javascript" data-language="javascript" data-start="4" data-line="5,7" data-line-offset="3"><code class="language-javascript">
function $initHighlight(block, cls) &#123; 
  try &#123; 
    if (cls.search(&#x2F;\bno\-highlight\b&#x2F;) !&#x3D; -1) 
      return process(block, true, 0x0F) + 
             &#96; class&#x3D;&quot;$&#123;cls&#125;&quot;&#96;; 
  &#125; catch (e) &#123; 
    &#x2F;* handle exception *&#x2F; 
  &#125; 
  for (var i &#x3D; 0 &#x2F; 2; i &lt; classes.length; i++) &#123; 
    if (checkCondition(classes[i]) &#x3D;&#x3D;&#x3D; undefined) 
      console.log(&#39;undefined&#39;); 
  &#125;

  return ( 
    &lt;div&gt; 
      &lt;web-component&gt;&#123;block&#125;&lt;&#x2F;web-component&gt; 
    &lt;&#x2F;div&gt; 
  ) 
&#125;

export $initHighlight; </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/04/24/hello-world/" data-id="clhldf9fn0003gspuddpbc5sq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/bk/categories/MQ/">MQ</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/bk/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/bk/tags/MQ/" style="font-size: 20px;">MQ</a> <a href="/bk/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/bk/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/bk/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/bk/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/bk/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/bk/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90Seata%E3%80%91seata%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%9B%86%E6%88%90/">【Seata】seata的部署与集成</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90ES6%E3%80%91ES6%E8%AF%AD%E6%B3%95/">【ES6】ES6语法</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90k3s%E3%80%91K3sa%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/">【k3s】K3s安装与部署</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/07/%E3%80%90MQ%E3%80%91MQ%E6%A6%82%E8%BF%B0/">【MQ】MQ概念与选用</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">【MQ】RabbitMQ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 cwh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/bk/" class="mobile-nav-link">Home</a>
  
    <a href="/bk/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/bk/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/bk/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/bk/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/bk/fancybox/jquery.fancybox.css">

  
<script src="/bk/fancybox/jquery.fancybox.pack.js"></script>




<script src="/bk/js/script.js"></script>




  </div>
</body>
</html>