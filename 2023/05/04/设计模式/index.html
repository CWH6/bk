<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>【设计模式】23 种设计模式 | ChenWeiHui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="设置模式介绍设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。  设计模式的使用设计模式在软件开发中的两个主要用途。 1） 开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种">
<meta property="og:type" content="article">
<meta property="og:title" content="【设计模式】23 种设计模式">
<meta property="og:url" content="https://gitee.com/CWH6/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="ChenWeiHui&#39;s Blog">
<meta property="og:description" content="设置模式介绍设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。  设计模式的使用设计模式在软件开发中的两个主要用途。 1） 开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504213909572.png">
<meta property="og:image" content="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504224216544.png">
<meta property="og:image" content="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504230436259.png">
<meta property="article:published_time" content="2023-05-04T11:52:49.000Z">
<meta property="article:modified_time" content="2023-05-04T15:22:01.573Z">
<meta property="article:author" content="cwh">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504213909572.png">
  
    <link rel="alternate" href="/bk/atom.xml" title="ChenWeiHui&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/bk/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/bk/" id="logo">ChenWeiHui&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/bk/">Home</a>
        
          <a class="main-nav-link" href="/bk/tags">Tags</a>
        
          <a class="main-nav-link" href="/bk/archives">Archives</a>
        
          <a class="main-nav-link" href="/bk/categories">Categories</a>
        
          <a class="main-nav-link" href="/bk/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/bk/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://gitee.com/CWH6"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/bk/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2023-05-04T11:52:49.000Z" itemprop="datePublished">2023-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/bk/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【设计模式】23 种设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设置模式介绍"><a href="#设置模式介绍" class="headerlink" title="设置模式介绍"></a>设置模式介绍</h2><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p>
<p>1） <strong>开发人员的共同平台</strong></p>
<p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，<strong>这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</strong></p>
<p>2）<strong>最佳的实践</strong></p>
<p>设计模式已经经历了很长一段时间的发展，<strong>它们提供了软件开发过程中面临的一般问题的最佳解决方案</strong>。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p>
<h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时<br>隐藏创建逻辑的方式，而不是使用 new 运算<br/>符直接实例化对象。这使得程序在判断针对<br/>某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式（Factory Pattern）</strong> <br> 抽象工厂模式（Abstract Factory Pattern）<br> <strong>单例模式（Singleton Pattern）</strong><br><strong>建造者模式（Builder Pattern）</strong> <br> 原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>结构型模式</strong><br> 这些设计模式关注类和对象的组合。继承的<br/>概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left">适配器模式（Adapter Pattern）<br> 桥接模式（Bridge Pattern）<br> 过滤器模式（Filter、Criteria Pattern） <br>组合模式（Composite Pattern）<br> 装饰器模式（Decorator Pattern）<br> 外观模式（Facade Pattern）<br> 享元模式（Flyweight Pattern）<br> <strong>代理模式（Proxy Pattern）</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>行为型模式</strong><br> 这些设计模式特别关注对象之间的通信。</td>
<td align="left">责任链模式（Chain of Responsibility Pattern） <br>命令模式（Command Pattern）<br> 解释器模式（Interpreter Pattern） <br>迭代器模式（Iterator Pattern）<br> 中介者模式（Mediator Pattern）<br> 备忘录模式（Memento Pattern）<br> <strong>观察者模式（Observer Pattern）</strong><br> 状态模式（State Pattern）<br> 空对象模式（Null Object Pattern）<br> <strong>策略模式（Strategy Pattern）</strong><br> 模板模式（Template Pattern）<br> 访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。<br/>这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left"><strong>MVC 模式（MVC Pattern）</strong><br> 业务代表模式（Business Delegate Pattern）<br> 组合实体模式（Composite Entity Pattern）<br> 数据访问对象模式（Data Access Object Pattern）<br> <strong>前端控制器模式（Front Controller Pattern）</strong><br> <strong>拦截过滤器模式（Intercepting Filter Pattern）</strong><br> 服务定位器模式（Service Locator Pattern）<br> 传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。<strong>在程序需要进行拓展的时候，不能去修改原有的代码</strong>，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则是面向对象设计的基本原则之一。<strong>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现</strong>。LSP  是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。<strong>实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现</strong>，所以<strong>里氏代换原则是对实现抽象化的具体步骤的规范。</strong></p>
<h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<h4 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h4><p>这个原则的意思是：<strong>使用多个隔离的接口，比使用单个接口要好</strong>。它还有另外一个意思是：<strong>降低类之间的耦合度</strong>。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<h4 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a>5、迪米特法则，又称最少知道原则（Demeter Principle）</h4><p>最少知道原则是指：一个<strong>实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</strong>。</p>
<h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>合成复用原则是指：尽量使用<strong>合成/聚合的方式，而不是使用继承</strong>。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过<strong>使用一个共同的接口来指向新创建的对象</strong>。</p>
<p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>优点：</strong></p>
<p> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 </p>
<p> 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>
<p> 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong></p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>使用场景：</strong> </p>
<p> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</p>
<p> 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p>
<p> 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何<strong>需要生成复杂对象的地方，都可以使用工厂方法模式。</strong>有一点需要注意的地方就是复杂对象适合使用工厂模式，而<strong>简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式</strong>。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。</p>
<p>下一步是定义工厂类 <em>ShapeFactory</em>。</p>
<p><em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。<em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504213909572.png"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 图形
 *&#x2F;
public interface Shape &#123;
   void draw();
&#125;</code></pre>

<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形
 *&#x2F;
public class Rectangle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 正方形
 *&#x2F;
public class Square implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 圆形
 *&#x2F;
public class Circle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class ShapeFactory &#123;
    
   &#x2F;&#x2F;使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType)&#123;
      if(shapeType &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;
         return new Circle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;
         return new Rectangle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;
         return new Square();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>

<p><strong>步骤4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FactoryPatternDemo &#123;
 
   public static void main(String[] args) &#123;
      ShapeFactory shapeFactory &#x3D; new ShapeFactory();
 
      &#x2F;&#x2F;获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);
      &#x2F;&#x2F;调用 Circle 的 draw 方法
      shape1.draw();
 
      &#x2F;&#x2F;获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);
      &#x2F;&#x2F;调用 Rectangle 的 draw 方法
      shape2.draw();
 
      &#x2F;&#x2F;获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);
      &#x2F;&#x2F;调用 Square 的 draw 方法
      shape3.draw();
   &#125;
&#125;
</code></pre>

<p><strong>步骤 5</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.</code></pre>



<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。</p>
<p>下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。</p>
<p>然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p>
<p><em>AbstractFactoryPatternDemo</em> 类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504224216544.png"></p>
<p><strong>步骤1</strong></p>
<p>为形状创建一个接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Shape &#123;
   void draw();
&#125;</code></pre>



<p><strong>步骤2</strong></p>
<p>创建实现接口的实体类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形状
 *&#x2F;
public class Rectangle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 长方形状
 *&#x2F;
public class Square implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 圆形
 *&#x2F;
public class Circle implements Shape &#123;
 
   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   &#125;
&#125;
</code></pre>



<p><strong>步骤3</strong></p>
<p>为颜色创建一个接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Color &#123;
   void fill();
&#125;</code></pre>



<p><strong>步骤4</strong></p>
<p>创建实现接口的实体类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Red implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Red::fill() method.&quot;);
   &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Green implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Green::fill() method.&quot;);
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Blue implements Color &#123;
 
   @Override
   public void fill() &#123;
      System.out.println(&quot;Inside Blue::fill() method.&quot;);
   &#125;
&#125;
</code></pre>



<p><strong>步骤5</strong></p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractFactory &#123;
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
&#125;</code></pre>



<p><strong>步骤6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShapeFactory extends AbstractFactory &#123;
    
   @Override
   public Shape getShape(String shapeType)&#123;
      if(shapeType &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;
         return new Circle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;
         return new Rectangle();
      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;
         return new Square();
      &#125;
      return null;
   &#125;
   
   @Override
   public Color getColor(String color) &#123;
      return null;
   &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ColorFactory extends AbstractFactory &#123;
    
   @Override
   public Shape getShape(String shapeType)&#123;
      return null;
   &#125;
   
   @Override
   public Color getColor(String color) &#123;
      if(color &#x3D;&#x3D; null)&#123;
         return null;
      &#125;        
      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;
         return new Red();
      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;
         return new Green();
      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;
         return new Blue();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>



<p><strong>步骤7</strong></p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FactoryProducer &#123;
   public static AbstractFactory getFactory(String choice)&#123;
      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;
         return new ShapeFactory();
      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;
         return new ColorFactory();
      &#125;
      return null;
   &#125;
&#125;
</code></pre>



<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class AbstractFactoryPatternDemo &#123;
   public static void main(String[] args) &#123;
 
      &#x2F;&#x2F;获取形状工厂
      AbstractFactory shapeFactory &#x3D; FactoryProducer.getFactory(&quot;SHAPE&quot;);
      
       &#x2F;&#x2F;获取形状为 Circle 的对象
      Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);
      &#x2F;&#x2F;调用 Circle 的 draw 方法
      shape1.draw();
 
      &#x2F;&#x2F;获取形状为 Rectangle 的对象
      Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);
      &#x2F;&#x2F;调用 Rectangle 的 draw 方法
      shape2.draw();
       
      &#x2F;&#x2F;获取形状为 Square 的对象
      Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);
      &#x2F;&#x2F;调用 Square 的 draw 方法
      shape3.draw();
 
      &#x2F;&#x2F;获取颜色工厂
      AbstractFactory colorFactory &#x3D; FactoryProducer.getFactory(&quot;COLOR&quot;);
      
       &#x2F;&#x2F;获取颜色为 Red 的对象
      Color color1 &#x3D; colorFactory.getColor(&quot;RED&quot;);
      &#x2F;&#x2F;调用 Red 的 fill 方法
      color1.fill();
       
      &#x2F;&#x2F;获取颜色为 Green 的对象
      Color color2 &#x3D; colorFactory.getColor(&quot;GREEN&quot;);
      &#x2F;&#x2F;调用 Green 的 fill 方法
      color2.fill();
 
      &#x2F;&#x2F;获取颜色为 Blue 的对象
      Color color3 &#x3D; colorFactory.getColor(&quot;BLUE&quot;);
      &#x2F;&#x2F;调用 Blue 的 fill 方法
      color3.fill();
   &#125;
&#125;
</code></pre>



<p><strong>步骤9</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.</code></pre>



<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。 </li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>SingleObject</em> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。 </p>
<p><em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo</em> 类使用 <em>SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p>
<p><img src="https://cwh6-bucket.oss-cn-shanghai.aliyuncs.com/bk/image-20230504230436259.png"></p>
<p>下面实现为饿汉式，线程安全。</p>
<p><strong>步骤1</strong></p>
<p>创建一个 Singleton 类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SingleObject &#123;
 
   &#x2F;&#x2F;创建 SingleObject 的一个对象
   private static SingleObject instance &#x3D; new SingleObject();
 
   &#x2F;&#x2F;让构造函数为 private，这样该类就不会被实例化
   private SingleObject()&#123;&#125;
 
   &#x2F;&#x2F;获取唯一可用的对象
   public static SingleObject getInstance()&#123;
      return instance;
   &#125;
 
   public void showMessage()&#123;
      System.out.println(&quot;Hello World!&quot;);
   &#125;
&#125;</code></pre>



<p><strong>步骤2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SingletonPatternDemo &#123;
   public static void main(String[] args) &#123;
 
      &#x2F;&#x2F;不合法的构造函数
      &#x2F;&#x2F;编译时错误：构造函数 SingleObject() 是不可见的
      &#x2F;&#x2F;SingleObject object &#x3D; new SingleObject();
 
      &#x2F;&#x2F;获取唯一可用的对象
      SingleObject object &#x3D; SingleObject.getInstance();
 
      &#x2F;&#x2F;显示消息
      object.showMessage();
   &#125;
&#125;
</code></pre>



<p><strong>步骤 3</strong></p>
<p>执行程序，输出结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Hello World!</code></pre>



<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><p>最近找工作忙死，晚点更新……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitee.com/CWH6/2023/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clhldf9gt000zgspu38bj2yvu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/bk/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          【MQ】RabbitMQ
        
      </div>
    </a>
  
  
    <a href="/bk/2023/05/04/%E3%80%90nigix%E3%80%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">【nginx】反向代理与负载均衡</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/bk/categories/MQ/">MQ</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/bk/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/bk/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/bk/tags/MQ/" style="font-size: 20px;">MQ</a> <a href="/bk/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/bk/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/bk/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/bk/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/bk/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/bk/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/bk/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90Seata%E3%80%91seata%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%9B%86%E6%88%90/">【Seata】seata的部署与集成</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90ES6%E3%80%91ES6%E8%AF%AD%E6%B3%95/">【ES6】ES6语法</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/10/%E3%80%90k3s%E3%80%91K3sa%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/">【k3s】K3s安装与部署</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/07/%E3%80%90MQ%E3%80%91MQ%E6%A6%82%E8%BF%B0/">【MQ】MQ概念与选用</a>
          </li>
        
          <li>
            <a href="/bk/2023/05/05/%E3%80%90RabbitMQ%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">【MQ】RabbitMQ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 cwh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/bk/" class="mobile-nav-link">Home</a>
  
    <a href="/bk/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/bk/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/bk/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/bk/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/bk/fancybox/jquery.fancybox.css">

  
<script src="/bk/fancybox/jquery.fancybox.pack.js"></script>




<script src="/bk/js/script.js"></script>




  </div>
</body>
</html>